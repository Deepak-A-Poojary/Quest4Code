[
  {
    "title": "Calculate Area of a Rectangle",
    "description": "Given the length and width of a rectangle, calculate its area.",
    "difficulty": "EASY",
    "tags": ["maths", "geometry"],
    "examples": {
      "PYTHON": {
        "input": "5 10",
        "output": "50",
        "explanation": "Area of a rectangle with length 5 and width 10 is 5 * 10 = 50"
      },
      "JAVASCRIPT": {
        "input": "7 3",
        "output": "21",
        "explanation": "Area of a rectangle with length 7 and width 3 is 7 * 3 = 21"
      },
      "JAVA": {
        "input": "4 6",
        "output": "24",
        "explanation": "Area of a rectangle with length 4 and width 6 is 4 * 6 = 24"
      }
    },
    "constraints": "1 <= length, width <= 10^9",
    "hints": "Area of a rectangle = length * width.",
    "testCases": [
      {
        "input": "1 1",
        "output": "1"
      },
      {
        "input": "100 2",
        "output": "200"
      },
      {
        "input": "12345 67890",
        "output": "838102050"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction calculateRectangleArea(length, width) {\n  return length * width;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\nconst [length, width] = input.split(' ').map(Number);\n\nconsole.log(calculateRectangleArea(length, width));",
      "PYTHON": "def calculate_rectangle_area(length, width):\n    return length * width\n\nimport sys\ninput_line = sys.stdin.read().strip()\nlength, width = map(int, input_line.split())\n\nprint(calculate_rectangle_area(length, width))",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public static int calculateRectangleArea(int length, int width) {\n        return length * width;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int length = sc.nextInt();\n        int width = sc.nextInt();\n        System.out.println(calculateRectangleArea(length, width));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\nconst [length, width] = input.split(' ').map(Number);\nconsole.log(length * width);",
      "PYTHON": "import sys\ninput_line = sys.stdin.read()\nlength, width = map(int, input_line.split())\nprint(length * width)",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int length = sc.nextInt();\n        int width = sc.nextInt();\n        System.out.println(length * width);\n    }\n}"
    },
    "editorial": "This problem requires a basic understanding of geometric formulas. Read the two dimensions and apply the multiplication operator to find the area."
  },
  {
    "title": "Check if a Number is Even or Odd",
    "description": "Given an integer, determine if it is even or odd.",
    "difficulty": "EASY",
    "tags": ["conditionals", "maths"],
    "examples": {
      "PYTHON": {
        "input": "4",
        "output": "Even",
        "explanation": "4 is divisible by 2, so it's even."
      },
      "JAVASCRIPT": {
        "input": "7",
        "output": "Odd",
        "explanation": "7 is not divisible by 2, so it's odd."
      },
      "JAVA": {
        "input": "0",
        "output": "Even",
        "explanation": "0 is considered an even number."
      }
    },
    "constraints": "-10^9 <= n <= 10^9",
    "hints": "Use the modulo operator (%) to check for divisibility by 2.",
    "testCases": [
      {
        "input": "2",
        "output": "Even"
      },
      {
        "input": "9",
        "output": "Odd"
      },
      {
        "input": "-6",
        "output": "Even"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction checkEvenOrOdd(n) {\n  return n % 2 === 0 ? 'Even' : 'Odd';\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\nconst n = parseInt(input);\n\nconsole.log(checkEvenOrOdd(n));",
      "PYTHON": "def check_even_or_odd(n):\n    return 'Even' if n % 2 == 0 else 'Odd'\n\nimport sys\ninput_line = sys.stdin.read().strip()\nn = int(input_line)\n\nprint(check_even_or_odd(n))",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public static String checkEvenOrOdd(int n) {\n        return n % 2 == 0 ? \"Even\" : \"Odd\";\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        System.out.println(checkEvenOrOdd(n));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst n = parseInt(fs.readFileSync(0, 'utf-8').trim());\nconsole.log(n % 2 === 0 ? 'Even' : 'Odd');",
      "PYTHON": "import sys\nn = int(sys.stdin.read().strip())\nprint('Even' if n % 2 == 0 else 'Odd')",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        System.out.println(n % 2 == 0 ? \"Even\" : \"Odd\");\n    }\n}"
    },
    "editorial": "The most straightforward way to determine if a number is even or odd is to use the modulo operator. If a number divided by 2 has a remainder of 0, it's even; otherwise, it's odd."
  },
  {
    "title": "Sum of Array Elements",
    "description": "Given an array of integers, return the sum of its elements.",
    "difficulty": "EASY",
    "tags": ["arrays", "loops", "maths"],
    "examples": {
      "PYTHON": {
        "input": "1 2 3 4 5",
        "output": "15",
        "explanation": "1 + 2 + 3 + 4 + 5 = 15"
      },
      "JAVASCRIPT": {
        "input": "10 20 30",
        "output": "60",
        "explanation": "10 + 20 + 30 = 60"
      },
      "JAVA": {
        "input": "100",
        "output": "100",
        "explanation": "The array contains only one element, so its sum is 100."
      }
    },
    "constraints": "1 <= N <= 1000 (number of elements), -10^9 <= element <= 10^9",
    "hints": "Iterate through the array and accumulate the sum.",
    "testCases": [
      {
        "input": "0",
        "output": "0"
      },
      {
        "input": "-1 -2 -3",
        "output": "-6"
      },
      {
        "input": "5 5 5 5 5",
        "output": "25"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction sumArrayElements(arr) {\n  return arr.reduce((sum, current) => sum + current, 0);\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\nconst arr = input.split(' ').map(Number);\n\nconsole.log(sumArrayElements(arr));",
      "PYTHON": "def sum_array_elements(arr):\n    return sum(arr)\n\nimport sys\ninput_line = sys.stdin.read().strip()\narr = list(map(int, input_line.split()))\n\nprint(sum_array_elements(arr))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static long sumArrayElements(int[] arr) {\n        long sum = 0;\n        for (int num : arr) {\n            sum += num;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] inputStr = sc.nextLine().split(\" \");\n        int[] arr = new int[inputStr.length];\n        for (int i = 0; i < inputStr.length; i++) {\n            arr[i] = Integer.parseInt(inputStr[i]);\n        }\n        System.out.println(sumArrayElements(arr));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst arr = fs.readFileSync(0, 'utf-8').trim().split(' ').map(Number);\nconst sum = arr.reduce((acc, curr) => acc + curr, 0);\nconsole.log(sum);",
      "PYTHON": "import sys\narr = list(map(int, sys.stdin.read().strip().split()))\nprint(sum(arr))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] inputStr = sc.nextLine().split(\" \");\n        long sum = 0;\n        for (String s : inputStr) {\n            sum += Integer.parseInt(s);\n        }\n        System.out.println(sum);\n    }\n}"
    },
    "editorial": "To find the sum of array elements, initialize a sum variable to 0. Then, iterate through each element in the array and add it to the sum. Finally, print the sum."
  },
  {
    "title": "Find the Maximum Element in an Array",
    "description": "Given an array of integers, find the maximum element.",
    "difficulty": "EASY",
    "tags": ["arrays", "loops"],
    "examples": {
      "PYTHON": {
        "input": "1 5 2 9 3",
        "output": "9",
        "explanation": "The largest number in the array is 9."
      },
      "JAVASCRIPT": {
        "input": "10 2 8 4 6",
        "output": "10",
        "explanation": "The largest number in the array is 10."
      },
      "JAVA": {
        "input": "-1 -5 -2 -9 -3",
        "output": "-1",
        "explanation": "The largest number in the array is -1."
      }
    },
    "constraints": "1 <= N <= 1000 (number of elements), -10^9 <= element <= 10^9",
    "hints": "Initialize a variable with the first element and update it if a larger element is found.",
    "testCases": [
      {
        "input": "7",
        "output": "7"
      },
      {
        "input": "100 0 -50 200",
        "output": "200"
      },
      {
        "input": "99 99 99",
        "output": "99"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction findMax(arr) {\n  if (arr.length === 0) return undefined; // Handle empty array case\n  return Math.max(...arr);\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\nconst arr = input.split(' ').map(Number);\n\nconsole.log(findMax(arr));",
      "PYTHON": "def find_max(arr):\n    if not arr: return None\n    return max(arr)\n\nimport sys\ninput_line = sys.stdin.read().strip()\narr = list(map(int, input_line.split()))\n\nprint(find_max(arr))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static int findMax(int[] arr) {\n        if (arr.length == 0) throw new IllegalArgumentException(\"Array cannot be empty\");\n        int max = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n            }\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] inputStr = sc.nextLine().split(\" \");\n        int[] arr = new int[inputStr.length];\n        for (int i = 0; i < inputStr.length; i++) {\n            arr[i] = Integer.parseInt(inputStr[i]);\n        }\n        System.out.println(findMax(arr));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst arr = fs.readFileSync(0, 'utf-8').trim().split(' ').map(Number);\nconsole.log(Math.max(...arr));",
      "PYTHON": "import sys\narr = list(map(int, sys.stdin.read().strip().split()))\nprint(max(arr))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] inputStr = sc.nextLine().split(\" \");\n        int max = Integer.MIN_VALUE;\n        for (String s : inputStr) {\n            int num = Integer.parseInt(s);\n            if (num > max) {\n                max = num;\n            }\n        }\n        System.out.println(max);\n    }\n}"
    },
    "editorial": "To find the maximum element, initialize a variable `max_element` with the first element of the array. Then, iterate through the rest of the array. If any element is greater than `max_element`, update `max_element` with that value. After iterating through all elements, `max_element` will hold the maximum value."
  },
  {
    "title": "Reverse a String",
    "description": "Given a string, return a new string with the characters in reverse order.",
    "difficulty": "MEDIUM",
    "tags": ["strings", "arrays"],
    "examples": {
      "PYTHON": {
        "input": "hello",
        "output": "olleh",
        "explanation": "The reversed string of 'hello' is 'olleh'."
      },
      "JAVASCRIPT": {
        "input": "world",
        "output": "dlrow",
        "explanation": "The reversed string of 'world' is 'dlrow'."
      },
      "JAVA": {
        "input": "racecar",
        "output": "racecar",
        "explanation": "The string 'racecar' is a palindrome, so it remains the same when reversed."
      }
    },
    "constraints": "1 <= length of string <= 1000",
    "hints": "You can convert the string to a character array, reverse the array, and then convert it back to a string. Alternatively, iterate from the end of the string.",
    "testCases": [
      {
        "input": "a",
        "output": "a"
      },
      {
        "input": "madam",
        "output": "madam"
      },
      {
        "input": "12345",
        "output": "54321"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction reverseString(str) {\n  return str.split('').reverse().join('');\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\n\nconsole.log(reverseString(input));",
      "PYTHON": "def reverse_string(s):\n    return s[::-1]\n\nimport sys\ninput_line = sys.stdin.read().strip()\n\nprint(reverse_string(input_line))",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public static String reverseString(String str) {\n        return new StringBuilder(str).reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.nextLine();\n        System.out.println(reverseString(str));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst str = fs.readFileSync(0, 'utf-8').trim();\nconsole.log(str.split('').reverse().join(''));",
      "PYTHON": "import sys\nprint(sys.stdin.read().strip()[::-1])",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.nextLine();\n        System.out.println(new StringBuilder(str).reverse().toString());\n    }\n}"
    },
    "editorial": "A common way to reverse a string is to convert it into a character array, then swap characters from the beginning and end until the middle is reached. Many languages also provide built-in functions for string reversal."
  },
  {
    "title": "Factorial of a Number",
    "description": "Calculate the factorial of a given non-negative integer.",
    "difficulty": "MEDIUM",
    "tags": ["maths", "recursion", "loops"],
    "examples": {
      "PYTHON": {
        "input": "5",
        "output": "120",
        "explanation": "5! = 5 * 4 * 3 * 2 * 1 = 120"
      },
      "JAVASCRIPT": {
        "input": "0",
        "output": "1",
        "explanation": "The factorial of 0 is defined as 1."
      },
      "JAVA": {
        "input": "7",
        "output": "5040",
        "explanation": "7! = 7 * 6 * 5 * 4 * 3 * 2 * 1 = 5040"
      }
    },
    "constraints": "0 <= n <= 20 (to avoid overflow for standard integer types)",
    "hints": "Factorial can be calculated iteratively by multiplying numbers from 1 to n, or recursively by using the definition n! = n * (n-1)!.",
    "testCases": [
      {
        "input": "1",
        "output": "1"
      },
      {
        "input": "4",
        "output": "24"
      },
      {
        "input": "10",
        "output": "3628800"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction factorial(n) {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  let result = 1;\n  for (let i = 2; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\nconst n = parseInt(input);\n\nconsole.log(factorial(n));",
      "PYTHON": "def factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    res = 1\n    for i in range(2, n + 1):\n        res *= i\n    return res\n\nimport sys\ninput_line = sys.stdin.read().strip()\nn = int(input_line)\n\nprint(factorial(n))",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public static long factorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        long result = 1;\n        for (int i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        System.out.println(factorial(n));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst n = parseInt(fs.readFileSync(0, 'utf-8').trim());\nlet result = 1;\nfor (let i = 2; i <= n; i++) {\n  result *= i;\n}\nconsole.log(result);",
      "PYTHON": "import sys\nn = int(sys.stdin.read().strip())\nres = 1\nfor i in range(2, n + 1):\n    res *= i\nprint(res)",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long result = 1;\n        if (n == 0 || n == 1) {\n            System.out.println(1);\n        } else {\n            for (int i = 2; i <= n; i++) {\n                result *= i;\n            }\n            System.out.println(result);\n        }\n    }\n}"
    },
    "editorial": "The factorial of a non-negative integer n, denoted by n!, is the product of all positive integers less than or equal to n. The base cases are 0! = 1 and 1! = 1. For n > 1, it can be computed iteratively or recursively."
  },

  {
    "title": "Check for Palindrome String",
    "description": "Given a string, determine if it is a palindrome. A palindrome reads the same forwards and backwards.",
    "difficulty": "MEDIUM",
    "tags": ["strings", "conditionals"],
    "examples": {
      "PYTHON": {
        "input": "madam",
        "output": "True",
        "explanation": "'madam' reads the same forwards and backwards."
      },
      "JAVASCRIPT": {
        "input": "hello",
        "output": "False",
        "explanation": "'hello' does not read the same forwards and backwards."
      },
      "JAVA": {
        "input": "level",
        "output": "True",
        "explanation": "'level' reads the same forwards and backwards."
      }
    },
    "constraints": "1 <= length of string <= 1000",
    "hints": "Compare characters from the beginning and end of the string, moving inwards.",
    "testCases": [
      {
        "input": "a",
        "output": "True"
      },
      {
        "input": "racecar",
        "output": "True"
      },
      {
        "input": "programming",
        "output": "False"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction isPalindrome(str) {\n  const reversedStr = str.split('').reverse().join('');\n  return str === reversedStr;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\n\nconsole.log(isPalindrome(input));",
      "PYTHON": "def is_palindrome(s):\n    return s == s[::-1]\n\nimport sys\ninput_line = sys.stdin.read().strip()\n\nprint(is_palindrome(input_line))",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public static boolean isPalindrome(String str) {\n        String reversedStr = new StringBuilder(str).reverse().toString();\n        return str.equals(reversedStr);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.nextLine();\n        System.out.println(isPalindrome(str));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst str = fs.readFileSync(0, 'utf-8').trim();\nconst reversedStr = str.split('').reverse().join('');\nconsole.log(str === reversedStr);",
      "PYTHON": "import sys\ns = sys.stdin.read().strip()\nprint(s == s[::-1])",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.nextLine();\n        boolean isPal = true;\n        int left = 0;\n        int right = str.length() - 1;\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                isPal = false;\n                break;\n            }\n            left++;\n            right--;\n        }\n        System.out.println(isPal);\n    }\n}"
    },
    "editorial": "To check if a string is a palindrome, you can compare characters from the beginning and end of the string. If all corresponding characters match as you move inwards, the string is a palindrome. Alternatively, reverse the string and check if it's equal to the original."
  },
  
  {
    "title": "Find the First Non-Repeating Character",
    "description": "Given a string, find the first non-repeating character in it and return its index. If it doesn't exist, return -1.",
    "difficulty": "MEDIUM",
    "tags": ["strings", "hashmaps"],
    "examples": {
      "PYTHON": {
        "input": "leetcode",
        "output": "0",
        "explanation": "The character 'l' is the first non-repeating character, and its index is 0."
      },
      "JAVASCRIPT": {
        "input": "loveleetcode",
        "output": "2",
        "explanation": "The character 'v' is the first non-repeating character, and its index is 2."
      },
      "JAVA": {
        "input": "aabb",
        "output": "-1",
        "explanation": "All characters repeat, so there is no non-repeating character."
      }
    },
    "constraints": "1 <= length of string <= 10^5",
    "hints": "You can use a hash map (or frequency array) to store character counts.",
    "testCases": [
      {
        "input": "z",
        "output": "0"
      },
      {
        "input": "abcabc",
        "output": "-1"
      },
      {
        "input": "aabbccddeeffgghhijjkkllmmnnooppqqrrssttuuvvwwxxyyzz",
        "output": "-1"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction firstUniqChar(s) {\n  const charCount = {};\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    charCount[char] = (charCount[char] || 0) + 1;\n  }\n\n  for (let i = 0; i < s.length; i++) {\n    if (charCount[s[i]] === 1) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\n\nconsole.log(firstUniqChar(input));",
      "PYTHON": "from collections import Counter\nimport sys\n\ndef first_uniq_char(s):\n    char_count = Counter(s)\n    for i, char in enumerate(s):\n        if char_count[char] == 1:\n            return i\n    return -1\n\ninput_line = sys.stdin.read().strip()\nprint(first_uniq_char(input_line))",
      "JAVA": "import java.util.Scanner;\nimport java.util.HashMap;\n\npublic class Main {\n    public static int firstUniqChar(String s) {\n        HashMap<Character, Integer> charCount = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            charCount.put(c, charCount.getOrDefault(c, 0) + 1);\n        }\n\n        for (int i = 0; i < s.length(); i++) {\n            if (charCount.get(s.charAt(i)) == 1) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.nextLine();\n        System.out.println(firstUniqChar(s));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst s = fs.readFileSync(0, 'utf-8').trim();\nconst charCount = {};\nfor (let i = 0; i < s.length; i++) {\n  const char = s[i];\n  charCount[char] = (charCount[char] || 0) + 1;\n}\n\nlet result = -1;\nfor (let i = 0; i < s.length; i++) {\n  if (charCount[s[i]] === 1) {\n    result = i;\n    break;\n  }\n}\nconsole.log(result);",
      "PYTHON": "from collections import Counter\nimport sys\n\ns = sys.stdin.read().strip()\nchar_count = Counter(s)\nresult = -1\nfor i, char in enumerate(s):\n    if char_count[char] == 1:\n        result = i\n        break\nprint(result)",
      "JAVA": "import java.util.Scanner;\nimport java.util.HashMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.nextLine();\n        HashMap<Character, Integer> charCount = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            charCount.put(c, charCount.getOrDefault(c, 0) + 1);\n        }\n\n        int result = -1;\n        for (int i = 0; i < s.length(); i++) {\n            if (charCount.get(s.charAt(i)) == 1) {\n                result = i;\n                break;\n            }\n        }\n        System.out.println(result);\n    }\n}"
    },
    "editorial": "A common approach is to use a hash map to store the frequency of each character in the string. After populating the hash map, iterate through the string again. The first character encountered with a frequency of 1 is the first non-repeating character, and its index is the answer. If no such character is found, return -1."
  },
  {
    "title": "Reverse an Array",
    "description": "Given an array of integers, reverse its elements in-place.",
    "difficulty": "EASY",
    "tags": ["arrays", "in-place"],
    "examples": {
      "PYTHON": {
        "input": "1 2 3 4 5",
        "output": "5 4 3 2 1",
        "explanation": "The array [1, 2, 3, 4, 5] becomes [5, 4, 3, 2, 1] after reversing."
      },
      "JAVASCRIPT": {
        "input": "10 20 30",
        "output": "30 20 10",
        "explanation": "The array [10, 20, 30] becomes [30, 20, 10] after reversing."
      },
      "JAVA": {
        "input": "100",
        "output": "100",
        "explanation": "An array with a single element remains unchanged after reversing."
      }
    },
    "constraints": "1 <= N <= 1000 (number of elements), -10^9 <= element <= 10^9",
    "hints": "Use two pointers, one at the beginning and one at the end, and swap elements.",
    "testCases": [
      {
        "input": "0",
        "output": "0"
      },
      {
        "input": "1 2",
        "output": "2 1"
      },
      {
        "input": "-1 -2 -3 -4",
        "output": "-4 -3 -2 -1"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction reverseArrayInPlace(arr) {\n  let left = 0;\n  let right = arr.length - 1;\n  while (left < right) {\n    [arr[left], arr[right]] = [arr[right], arr[left]]; // Swap elements\n    left++;\n    right--;\n  }\n  return arr;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\nconst arr = input.split(' ').map(Number);\n\nconsole.log(reverseArrayInPlace(arr).join(' '));",
      "PYTHON": "def reverse_array_in_place(arr):\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    return arr\n\nimport sys\ninput_line = sys.stdin.read().strip()\narr = list(map(int, input_line.split()))\n\nprint(*reverse_array_in_place(arr))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void reverseArrayInPlace(int[] arr) {\n        int left = 0;\n        int right = arr.length - 1;\n        while (left < right) {\n            int temp = arr[left];\n            arr[left] = arr[right];\n            arr[right] = temp;\n            left++;\n            right--;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] inputStr = sc.nextLine().split(\" \");\n        int[] arr = new int[inputStr.length];\n        for (int i = 0; i < inputStr.length; i++) {\n            arr[i] = Integer.parseInt(inputStr[i]);\n        }\n        reverseArrayInPlace(arr);\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + (i == arr.length - 1 ? \"\" : \" \"));\n        }\n        System.out.println();\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst arr = fs.readFileSync(0, 'utf-8').trim().split(' ').map(Number);\narr.reverse();\nconsole.log(arr.join(' '));",
      "PYTHON": "import sys\narr = list(map(int, sys.stdin.read().strip().split()))\narr.reverse()\nprint(*arr)",
      "JAVA": "import java.util.Scanner;\nimport java.util.Collections;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] inputStr = sc.nextLine().split(\" \");\n        int[] arr = new int[inputStr.length];\n        for (int i = 0; i < inputStr.length; i++) {\n            arr[i] = Integer.parseInt(inputStr[i]);\n        }\n        \n        int left = 0;\n        int right = arr.length - 1;\n        while(left < right) {\n            int temp = arr[left];\n            arr[left] = arr[right];\n            arr[right] = temp;\n            left++;\n            right--;\n        }\n\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + (i == arr.length - 1 ? \"\" : \" \"));\n        }\n        System.out.println();\n    }\n}"
    },
    "editorial": "The most efficient way to reverse an array in-place is to use two pointers, one starting at the beginning of the array and the other at the end. Swap the elements pointed to by these pointers, then move the left pointer forward and the right pointer backward. Continue this process until the pointers cross or meet."
  },

  {
    "title": "Merge Two Sorted Arrays",
    "description": "Given two sorted arrays, merge them into a single sorted array.",
    "difficulty": "MEDIUM",
    "tags": ["arrays", "sorting", "two-pointers"],
    "examples": {
      "PYTHON": {
        "input": "1 3 5\n2 4 6",
        "output": "1 2 3 4 5 6",
        "explanation": "Merging [1,3,5] and [2,4,6] results in [1,2,3,4,5,6]."
      },
      "JAVASCRIPT": {
        "input": "10 20\n5 15 25",
        "output": "5 10 15 20 25",
        "explanation": "Merging [10,20] and [5,15,25] results in [5,10,15,20,25]."
      },
      "JAVA": {
        "input": "1\n2",
        "output": "1 2",
        "explanation": "Merging [1] and [2] results in [1,2]."
      }
    },
    "constraints": "1 <= N, M <= 1000 (number of elements), -10^9 <= element <= 10^9",
    "hints": "Use two pointers, one for each array, and compare elements to build the merged array.",
    "testCases": [
      {
        "input": "1 2 3\n1 2 3",
        "output": "1 1 2 2 3 3"
      },
      {
        "input": "5 7 9\n2 4 6 8 10",
        "output": "2 4 5 6 7 8 9 10"
      },
      {
        "input": "100\n",
        "output": "100"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction mergeSortedArrays(arr1, arr2) {\n  const merged = [];\n  let i = 0;\n  let j = 0;\n\n  while (i < arr1.length && j < arr2.length) {\n    if (arr1[i] < arr2[j]) {\n      merged.push(arr1[i]);\n      i++;\n    } else {\n      merged.push(arr2[j]);\n      j++;\n    }\n  }\n\n  while (i < arr1.length) {\n    merged.push(arr1[i]);\n    i++;\n  }\n\n  while (j < arr2.length) {\n    merged.push(arr2[j]);\n    j++;\n  }\n  return merged;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst arr1 = input[0].split(' ').map(Number);\nconst arr2 = input[1] ? input[1].split(' ').map(Number) : [];\n\nconsole.log(mergeSortedArrays(arr1, arr2).join(' '));",
      "PYTHON": "def merge_sorted_arrays(arr1, arr2):\n    merged = []\n    i, j = 0, 0\n\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    return merged\n\nimport sys\ninput_lines = sys.stdin.read().strip().split('\\n')\narr1 = list(map(int, input_lines[0].split())) if input_lines[0] else []\narr2 = list(map(int, input_lines[1].split())) if len(input_lines) > 1 and input_lines[1] else []\n\nprint(*merge_sorted_arrays(arr1, arr2))",
      "JAVA": "import java.util.Scanner;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static ArrayList<Integer> mergeSortedArrays(int[] arr1, int[] arr2) {\n        ArrayList<Integer> merged = new ArrayList<>();\n        int i = 0;\n        int j = 0;\n\n        while (i < arr1.length && j < arr2.length) {\n            if (arr1[i] < arr2[j]) {\n                merged.add(arr1[i]);\n                i++;\n            } else {\n                merged.add(arr2[j]);\n                j++;\n            }\n        }\n\n        while (i < arr1.length) {\n            merged.add(arr1[i]);\n            i++;\n        }\n\n        while (j < arr2.length) {\n            merged.add(arr2[j]);\n            j++;\n        }\n        return merged;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line1 = sc.nextLine();\n        String line2 = sc.nextLine();\n\n        int[] arr1 = Arrays.stream(line1.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        int[] arr2 = Arrays.stream(line2.split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n        ArrayList<Integer> result = mergeSortedArrays(arr1, arr2);\n        System.out.println(result.stream().map(Object::toString).collect(Collectors.joining(\" \")));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst arr1 = input[0].split(' ').map(Number);\nconst arr2 = input[1] ? input[1].split(' ').map(Number) : [];\n\nconst merged = [];\nlet i = 0;\nlet j = 0;\n\nwhile (i < arr1.length && j < arr2.length) {\n  if (arr1[i] < arr2[j]) {\n    merged.push(arr1[i]);\n    i++;\n  } else {\n    merged.push(arr2[j]);\n    j++;\n  }\n}\n\nwhile (i < arr1.length) {\n  merged.push(arr1[i]);\n  i++;\n}\n\nwhile (j < arr2.length) {\n  merged.push(arr2[j]);\n  j++;\n}\nconsole.log(merged.join(' '));",
      "PYTHON": "import sys\ninput_lines = sys.stdin.read().strip().split('\\n')\narr1 = list(map(int, input_lines[0].split())) if input_lines[0] else []\narr2 = list(map(int, input_lines[1].split())) if len(input_lines) > 1 and input_lines[1] else []\n\nmerged = []\ni, j = 0, 0\n\nwhile i < len(arr1) and j < len(arr2):\n    if arr1[i] < arr2[j]:\n        merged.append(arr1[i])\n        i += 1\n    else:\n        merged.append(arr2[j])\n        j += 1\n\nwhile i < len(arr1):\n    merged.append(arr1[i])\n    i += 1\n\nwhile j < len(arr2):\n    merged.append(arr2[j])\n    j += 1\nprint(*merged)",
      "JAVA": "import java.util.Scanner;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line1 = sc.nextLine();\n        String line2 = sc.nextLine();\n\n        int[] arr1 = Arrays.stream(line1.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        int[] arr2 = Arrays.stream(line2.split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n        ArrayList<Integer> merged = new ArrayList<>();\n        int i = 0;\n        int j = 0;\n\n        while (i < arr1.length && j < arr2.length) {\n            if (arr1[i] < arr2[j]) {\n                merged.add(arr1[i]);\n                i++;\n            } else {\n                merged.add(arr2[j]);\n                j++;\n            }\n        }\n\n        while (i < arr1.length) {\n            merged.add(arr1[i]);\n            i++;\n        }\n\n        while (j < arr2.length) {\n            merged.add(arr2[j]);\n            j++;\n        }\n        System.out.println(merged.stream().map(Object::toString).collect(Collectors.joining(\" \")));\n    }\n}"
    },
    "editorial": "To merge two sorted arrays efficiently, use a two-pointer approach. Maintain pointers for each array, comparing the elements they point to. Add the smaller element to a new merged array and advance its pointer. Once one array is exhausted, add the remaining elements from the other array to the merged array."
  },

  {
    "title": "Remove Duplicates from Sorted Array",
    "description": "Given a sorted array, remove the duplicates in-place such that each element appears only once. The relative order of the elements should be kept the same. Return the new length of the array.",
    "difficulty": "MEDIUM",
    "tags": ["arrays", "in-place", "two-pointers"],
    "examples": {
      "PYTHON": {
        "input": "1 1 2",
        "output": "2\n1 2",
        "explanation": "The new length is 2, and the array becomes [1, 2]."
      },
      "JAVASCRIPT": {
        "input": "0 0 1 1 1 2 2 3 3 4",
        "output": "5\n0 1 2 3 4",
        "explanation": "The new length is 5, and the array becomes [0, 1, 2, 3, 4]."
      },
      "JAVA": {
        "input": "1 1 1 1 1",
        "output": "1\n1",
        "explanation": "The new length is 1, and the array becomes [1]."
      }
    },
    "constraints": "0 <= N <= 10^5 (number of elements), -10^9 <= element <= 10^9",
    "hints": "Use two pointers: one to iterate through the array and another to keep track of the unique elements' position.",
    "testCases": [
      {
        "input": "1",
        "output": "1\n1"
      },
      {
        "input": "1 2 3",
        "output": "3\n1 2 3"
      },
      {
        "input": "-5 -5 0 0 0 1 1 1",
        "output": "3\n-5 0 1"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction removeDuplicates(nums) {\n  if (nums.length === 0) return 0;\n\n  let i = 0;\n  for (let j = 1; j < nums.length; j++) {\n    if (nums[j] !== nums[i]) {\n      i++;\n      nums[i] = nums[j];\n    }\n  }\n  return i + 1;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\nconst nums = input.split(' ').map(Number);\n\nconst newLength = removeDuplicates(nums);\nconsole.log(newLength);\nconsole.log(nums.slice(0, newLength).join(' '));",
      "PYTHON": "def remove_duplicates(nums):\n    if not nums: return 0\n\n    i = 0\n    for j in range(1, len(nums)):\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n    return i + 1\n\nimport sys\ninput_lines = sys.stdin.read().strip().split('\\n')\nnums = list(map(int, input_lines[0].split())) if input_lines[0] else []\n\nnew_length = remove_duplicates(nums)\nprint(new_length)\nprint(*nums[:new_length])",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static int removeDuplicates(int[] nums) {\n        if (nums.length == 0) return 0;\n\n        int i = 0;\n        for (int j = 1; j < nums.length; j++) {\n            if (nums[j] != nums[i]) {\n                i++;\n                nums[i] = nums[j];\n            }\n        }\n        return i + 1;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        int[] nums = Arrays.stream(line.split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n        int newLength = removeDuplicates(nums);\n        System.out.println(newLength);\n        StringBuilder sb = new StringBuilder();\n        for (int k = 0; k < newLength; k++) {\n            sb.append(nums[k]);\n            if (k < newLength - 1) {\n                sb.append(\" \");\n            }\n        }\n        System.out.println(sb.toString());\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst nums = fs.readFileSync(0, 'utf-8').trim().split(' ').map(Number);\n\nif (nums.length === 0) {\n  console.log(0);\n  console.log('');\n} else {\n  let i = 0;\n  for (let j = 1; j < nums.length; j++) {\n    if (nums[j] !== nums[i]) {\n      i++;\n      nums[i] = nums[j];\n    }\n  }\n  const newLength = i + 1;\n  console.log(newLength);\n  console.log(nums.slice(0, newLength).join(' '));\n}",
      "PYTHON": "import sys\ninput_lines = sys.stdin.read().strip().split('\\n')\nnums = list(map(int, input_lines[0].split())) if input_lines[0] else []\n\nif not nums:\n    print(0)\n    print()\nelse:\n    i = 0\n    for j in range(1, len(nums)):\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n    new_length = i + 1\n    print(new_length)\n    print(*nums[:new_length])",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        int[] nums = Arrays.stream(line.split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n        if (nums.length == 0) {\n            System.out.println(0);\n            System.out.println();\n        } else {\n            int i = 0;\n            for (int j = 1; j < nums.length; j++) {\n                if (nums[j] != nums[i]) {\n                    i++;\n                    nums[i] = nums[j];\n                }\n            }\n            int newLength = i + 1;\n            System.out.println(newLength);\n            StringBuilder sb = new StringBuilder();\n            for (int k = 0; k < newLength; k++) {\n                sb.append(nums[k]);\n                if (k < newLength - 1) {\n                    sb.append(\" \");\n                }\n            }\n            System.out.println(sb.toString());\n        }\n    }\n}"
    },
    "editorial": "This problem can be solved using the two-pointer approach. Initialize a pointer `i` at 0 (which will represent the position for the next unique element) and another pointer `j` at 1. Iterate `j` through the array. If `nums[j]` is different from `nums[i]`, increment `i` and set `nums[i] = nums[j]`. This effectively moves unique elements to the front of the array. The final `i + 1` will be the new length of the array without duplicates."
  },  
  
  {
    "title": "Find Two Sum",
    "description": "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
    "difficulty": "HARD",
    "tags": ["arrays", "hashmaps", "two-pointers"],
    "examples": {
      "PYTHON": {
        "input": "2 7 11 15\n9",
        "output": "0 1",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      "JAVASCRIPT": {
        "input": "3 2 4\n6",
        "output": "1 2",
        "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."
      },
      "JAVA": {
        "input": "3 3\n6",
        "output": "0 1",
        "explanation": "Because nums[0] + nums[1] == 6, we return [0, 1]."
      }
    },
    "constraints": "2 <= nums.length <= 10^4, -10^9 <= nums[i] <= 10^9, -10^9 <= target <= 10^9",
    "hints": "Consider using a hash map to store numbers and their indices as you iterate through the array. For each number, check if the complement (target - current number) exists in the hash map.",
    "testCases": [
      {
        "input": "1 2 3 4 5\n7",
        "output": "1 4"
      },
      {
        "input": "0 0 1 2\n0",
        "output": "0 1"
      },
      {
        "input": "-1 -2 -3 -4 -5\n-8",
        "output": "2 5"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction twoSum(nums, target) {\n  const numMap = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (numMap.has(complement)) {\n      return [numMap.get(complement), i];\n    }\n    numMap.set(nums[i], i);\n  }\n  return []; // Should not reach here based on problem constraints\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst nums = input[0].split(' ').map(Number);\nconst target = parseInt(input[1]);\n\nconsole.log(twoSum(nums, target).join(' '));",
      "PYTHON": "def two_sum(nums, target):\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []\n\nimport sys\ninput_lines = sys.stdin.read().strip().split('\\n')\nnums = list(map(int, input_lines[0].split()))\ntarget = int(input_lines[1])\n\nprint(*two_sum(nums, target))",
      "JAVA": "import java.util.Scanner;\nimport java.util.HashMap;\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static int[] twoSum(int[] nums, int target) {\n        HashMap<Integer, Integer> numMap = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (numMap.containsKey(complement)) {\n                return new int[]{numMap.get(complement), i};\n            }\n            numMap.put(nums[i], i);\n        }\n        return new int[]{}; // Should not reach here based on problem constraints\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line1 = sc.nextLine();\n        int[] nums = Arrays.stream(line1.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        int target = sc.nextInt();\n\n        int[] result = twoSum(nums, target);\n        System.out.println(Arrays.stream(result).mapToObj(String::valueOf).collect(Collectors.joining(\" \")));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst nums = input[0].split(' ').map(Number);\nconst target = parseInt(input[1]);\n\nconst numMap = new Map();\nlet result = [];\nfor (let i = 0; i < nums.length; i++) {\n  const complement = target - nums[i];\n  if (numMap.has(complement)) {\n    result = [numMap.get(complement), i];\n    break;\n  }\n  numMap.set(nums[i], i);\n}\nconsole.log(result.join(' '));",
      "PYTHON": "import sys\ninput_lines = sys.stdin.read().strip().split('\\n')\nnums = list(map(int, input_lines[0].split()))\ntarget = int(input_lines[1])\n\nnum_map = {}\nresult = []\nfor i, num in enumerate(nums):\n    complement = target - num\n    if complement in num_map:\n        result = [num_map[complement], i]\n        break\n    num_map[num] = i\nprint(*result)",
      "JAVA": "import java.util.Scanner;\nimport java.util.HashMap;\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line1 = sc.nextLine();\n        int[] nums = Arrays.stream(line1.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        int target = sc.nextInt();\n\n        HashMap<Integer, Integer> numMap = new HashMap<>();\n        int[] result = new int[2];\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (numMap.containsKey(complement)) {\n                result[0] = numMap.get(complement);\n                result[1] = i;\n                break;\n            }\n            numMap.put(nums[i], i);\n        }\n        System.out.println(Arrays.stream(result).mapToObj(String::valueOf).collect(Collectors.joining(\" \")));\n    }\n}"
    },
    "editorial": "The Two Sum problem can be efficiently solved using a hash map. Iterate through the array, and for each number `num`, calculate its `complement` (i.e., `target - num`). Check if the `complement` already exists in the hash map. If it does, you've found the two numbers, and their indices are the current index and the index stored with the `complement` in the hash map. If the `complement` is not found, add the current `num` and its index to the hash map. This approach allows for a solution with O(N) time complexity."
  },

  {
    "title": "Convert Celsius to Fahrenheit",
    "description": "Given a temperature in Celsius, convert it to Fahrenheit.",
    "difficulty": "EASY",
    "tags": ["maths", "conversions"],
    "examples": {
      "PYTHON": {
        "input": "25",
        "output": "77.0",
        "explanation": "25 degrees Celsius is equivalent to 77 degrees Fahrenheit."
      },
      "JAVASCRIPT": {
        "input": "0",
        "output": "32.0",
        "explanation": "0 degrees Celsius is equivalent to 32 degrees Fahrenheit."
      },
      "JAVA": {
        "input": "100",
        "output": "212.0",
        "explanation": "100 degrees Celsius is equivalent to 212 degrees Fahrenheit."
      }
    },
    "constraints": "-100 <= celsius <= 100",
    "hints": "Use the formula: Fahrenheit = Celsius * 9/5 + 32.",
    "testCases": [
      {
        "input": "-10",
        "output": "14.0"
      },
      {
        "input": "37",
        "output": "98.6"
      },
      {
        "input": "-40",
        "output": "-40.0"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction celsiusToFahrenheit(celsius) {\n  return (celsius * 9 / 5) + 32;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\nconst celsius = parseFloat(input);\n\nconsole.log(celsiusToFahrenheit(celsius).toFixed(1));",
      "PYTHON": "def celsius_to_fahrenheit(celsius):\n    return (celsius * 9/5) + 32\n\nimport sys\ninput_line = sys.stdin.read().strip()\ncelsius = float(input_line)\n\nprint(f'{celsius_to_fahrenheit(celsius):.1f}')",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public static double celsiusToFahrenheit(double celsius) {\n        return (celsius * 9 / 5) + 32;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        double celsius = sc.nextDouble();\n        System.out.printf(\"%.1f%n\", celsiusToFahrenheit(celsius));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst celsius = parseFloat(fs.readFileSync(0, 'utf-8').trim());\nconsole.log(((celsius * 9 / 5) + 32).toFixed(1));",
      "PYTHON": "import sys\ncelsius = float(sys.stdin.read().strip())\nprint(f'{((celsius * 9/5) + 32):.1f}')",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        double celsius = sc.nextDouble();\n        System.out.printf(\"%.1f%n\", (celsius * 9 / 5) + 32);\n    }\n}"
    },
    "editorial": "This problem involves a straightforward temperature conversion. Read the Celsius value, apply the given formula to convert it to Fahrenheit, and then print the result, typically formatted to one decimal place."
  },
  {
    "title": "Count Vowels in a String",
    "description": "Given a string, return the count of vowels (a, e, i, o, u) in it. The string can contain both uppercase and lowercase letters.",
    "difficulty": "EASY",
    "tags": ["strings", "loops"],
    "examples": {
      "PYTHON": {
        "input": "hello",
        "output": "2",
        "explanation": "The vowels are 'e' and 'o'."
      },
      "JAVASCRIPT": {
        "input": "programming",
        "output": "4",
        "explanation": "The vowels are 'o', 'a', 'i', 'i'."
      },
      "JAVA": {
        "input": "AEIOU",
        "output": "5",
        "explanation": "All characters are vowels."
      }
    },
    "constraints": "1 <= length of string <= 1000",
    "hints": "Convert the string to lowercase for easier comparison. Iterate through the string and check if each character is a vowel.",
    "testCases": [
      {
        "input": "rhythm",
        "output": "0"
      },
      {
        "input": "Apple",
        "output": "2"
      },
      {
        "input": "education",
        "output": "5"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction countVowels(str) {\n  const vowels = 'aeiouAEIOU';\n  let count = 0;\n  for (let char of str) {\n    if (vowels.includes(char)) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\n\nconsole.log(countVowels(input));",
      "PYTHON": "def count_vowels(s):\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    return count\n\nimport sys\ninput_line = sys.stdin.read().strip()\n\nprint(count_vowels(input_line))",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public static int countVowels(String str) {\n        int count = 0;\n        String lowerStr = str.toLowerCase();\n        for (char c : lowerStr.toCharArray()) {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.nextLine();\n        System.out.println(countVowels(str));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst str = fs.readFileSync(0, 'utf-8').trim();\nconst vowels = 'aeiouAEIOU';\nlet count = 0;\nfor (let char of str) {\n  if (vowels.includes(char)) {\n    count++;\n  }\n}\nconsole.log(count);",
      "PYTHON": "import sys\ns = sys.stdin.read().strip()\nvowels = \"aeiouAEIOU\"\ncount = sum(1 for char in s if char in vowels)\nprint(count)",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.nextLine();\n        int count = 0;\n        String lowerStr = str.toLowerCase();\n        for (char c : lowerStr.toCharArray()) {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                count++;\n            }\n        }\n        System.out.println(count);\n    }\n}"
    },
    "editorial": "To count vowels in a string, initialize a counter to zero. Convert the string to lowercase to handle both cases uniformly. Iterate through each character of the string and check if it's one of the five vowels ('a', 'e', 'i', 'o', 'u'). If it is, increment the counter. Finally, print the total count."
  },
  
  {
    "title": "Check for Anagrams",
    "description": "Given two strings, determine if they are anagrams of each other. Anagrams are words or phrases formed by rearranging the letters of another, using all the original letters exactly once.",
    "difficulty": "MEDIUM",
    "tags": ["strings", "hashmaps", "sorting"],
    "examples": {
      "PYTHON": {
        "input": "listen\nsilent",
        "output": "True",
        "explanation": "'listen' and 'silent' are anagrams."
      },
      "JAVASCRIPT": {
        "input": "hello\nworld",
        "output": "False",
        "explanation": "'hello' and 'world' are not anagrams."
      },
      "JAVA": {
        "input": "Debit Card\nBad Credit",
        "output": "True",
        "explanation": "Ignoring spaces and case, 'Debit Card' and 'Bad Credit' are anagrams."
      }
    },
    "constraints": "1 <= length of strings <= 1000. Strings may contain spaces and special characters. Case-insensitive.",
    "hints": "Normalize both strings (convert to lowercase and remove spaces/non-alphabetic characters). Then, either sort the characters and compare, or use a frequency map.",
    "testCases": [
      {
        "input": "a\na",
        "output": "True"
      },
      {
        "input": "abc\nbca",
        "output": "True"
      },
      {
        "input": "abc\nabcd",
        "output": "False"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction areAnagrams(s1, s2) {\n  const cleanString = (str) => str.toLowerCase().replace(/[^a-z0-9]/g, '').split('').sort().join('');\n  return cleanString(s1) === cleanString(s2);\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst s1 = input[0];\nconst s2 = input[1];\n\nconsole.log(areAnagrams(s1, s2));",
      "PYTHON": "def are_anagrams(s1, s2):\n    def clean_string(s):\n        return sorted(c.lower() for c in s if c.isalnum())\n    return clean_string(s1) == clean_string(s2)\n\nimport sys\ninput_lines = sys.stdin.read().strip().split('\\n')\ns1 = input_lines[0]\ns2 = input_lines[1]\n\nprint(are_anagrams(s1, s2))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static boolean areAnagrams(String s1, String s2) {\n        String cleanS1 = s1.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n        String cleanS2 = s2.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n\n        if (cleanS1.length() != cleanS2.length()) {\n            return false;\n        }\n\n        char[] arr1 = cleanS1.toCharArray();\n        char[] arr2 = cleanS2.toCharArray();\n\n        Arrays.sort(arr1);\n        Arrays.sort(arr2);\n\n        return Arrays.equals(arr1, arr2);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s1 = sc.nextLine();\n        String s2 = sc.nextLine();\n        System.out.println(areAnagrams(s1, s2));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst s1 = input[0];\nconst s2 = input[1];\n\nconst cleanString = (str) => str.toLowerCase().replace(/[^a-z0-9]/g, '').split('').sort().join('');\nconsole.log(cleanString(s1) === cleanString(s2));",
      "PYTHON": "import sys\ninput_lines = sys.stdin.read().strip().split('\\n')\ns1 = input_lines[0]\ns2 = input_lines[1]\n\ndef clean_string(s):\n    return sorted(c.lower() for c in s if c.isalnum())\n\nprint(clean_string(s1) == clean_string(s2))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s1 = sc.nextLine();\n        String s2 = sc.nextLine();\n\n        String cleanS1 = s1.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n        String cleanS2 = s2.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n\n        if (cleanS1.length() != cleanS2.length()) {\n            System.out.println(false);\n            return;\n        }\n\n        char[] arr1 = cleanS1.toCharArray();\n        char[] arr2 = cleanS2.toCharArray();\n\n        Arrays.sort(arr1);\n        Arrays.sort(arr2);\n\n        System.out.println(Arrays.equals(arr1, arr2));\n    }\n}"
    },
    "editorial": "To check if two strings are anagrams, first normalize them by converting to lowercase and removing non-alphanumeric characters. Then, two common approaches are: 1) Sort the characters of both normalized strings and compare if the sorted strings are identical. 2) Use a frequency map (hash map or array) to count character occurrences in one string and decrement counts based on the second string; if all counts are zero at the end, they are anagrams."
  },

  {
    "title": "Find the Kth Smallest Element in an Array",
    "description": "Given an array of integers and an integer k, find the Kth smallest element in the array.",
    "difficulty": "MEDIUM",
    "tags": ["arrays", "sorting", "divide-and-conquer"],
    "examples": {
      "PYTHON": {
        "input": "3 2 1 5 6 4\n2",
        "output": "2",
        "explanation": "The 2nd smallest element in [3,2,1,5,6,4] is 2."
      },
      "JAVASCRIPT": {
        "input": "7 10 4 3 20 15\n3",
        "output": "7",
        "explanation": "The 3rd smallest element in [7,10,4,3,20,15] is 7."
      },
      "JAVA": {
        "input": "1 2 3 4 5\n5",
        "output": "5",
        "explanation": "The 5th smallest element in [1,2,3,4,5] is 5."
      }
    },
    "constraints": "1 <= N <= 10^5 (number of elements), 1 <= k <= N, -10^9 <= element <= 10^9",
    "hints": "Sorting the array is the simplest approach. More advanced solutions involve selection algorithms like QuickSelect or min-heaps.",
    "testCases": [
      {
        "input": "8 2 1 9\n1",
        "output": "1"
      },
      {
        "input": "5 4 3 2 1\n3",
        "output": "3"
      },
      {
        "input": "-10 -20 -5\n2",
        "output": "-10"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction findKthSmallest(arr, k) {\n  arr.sort((a, b) => a - b);\n  return arr[k - 1];\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst arr = input[0].split(' ').map(Number);\nconst k = parseInt(input[1]);\n\nconsole.log(findKthSmallest(arr, k));",
      "PYTHON": "def find_kth_smallest(arr, k):\n    arr.sort()\n    return arr[k-1]\n\nimport sys\ninput_lines = sys.stdin.read().strip().split('\\n')\narr = list(map(int, input_lines[0].split()))\nk = int(input_lines[1])\n\nprint(find_kth_smallest(arr, k))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static int findKthSmallest(int[] arr, int k) {\n        Arrays.sort(arr);\n        return arr[k - 1];\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line1 = sc.nextLine();\n        int[] arr = Arrays.stream(line1.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        int k = sc.nextInt();\n        System.out.println(findKthSmallest(arr, k));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst arr = input[0].split(' ').map(Number);\nconst k = parseInt(input[1]);\n\narr.sort((a, b) => a - b);\nconsole.log(arr[k - 1]);",
      "PYTHON": "import sys\ninput_lines = sys.stdin.read().strip().split('\\n')\narr = list(map(int, input_lines[0].split()))\nk = int(input_lines[1])\narr.sort()\nprint(arr[k-1])",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line1 = sc.nextLine();\n        int[] arr = Arrays.stream(line1.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        int k = sc.nextInt();\n        Arrays.sort(arr);\n        System.out.println(arr[k - 1]);\n    }\n}"
    },
    "editorial": "The simplest approach to find the Kth smallest element is to sort the array and then return the element at index `k-1` (since arrays are 0-indexed). More optimized solutions for larger datasets exist, such as QuickSelect (average O(N)) or using a min-heap (O(N log K))."
  },
  
  {
    "title": "Longest Common Prefix",
    "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string ''.",
    "difficulty": "MEDIUM",
    "tags": ["strings", "arrays"],
    "examples": {
      "PYTHON": {
        "input": "flower\nflow\nflight",
        "output": "fl",
        "explanation": "The longest common prefix is 'fl'."
      },
      "JAVASCRIPT": {
        "input": "dog\nracecar\ncar",
        "output": "",
        "explanation": "There is no common prefix among the input strings."
      },
      "JAVA": {
        "input": "apple\napply\napp",
        "output": "app",
        "explanation": "The longest common prefix is 'app'."
      }
    },
    "constraints": "1 <= strs.length <= 200, 0 <= strs[i].length <= 200",
    "hints": "Start with the first string as the initial prefix. Then, for each subsequent string, shorten the prefix until it is a prefix of the current string.",
    "testCases": [
      {
        "input": "a",
        "output": "a"
      },
      {
        "input": "apple\nbanana\norange",
        "output": ""
      },
      {
        "input": "abc\nab\nabcde",
        "output": "ab"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction longestCommonPrefix(strs) {\n  if (strs.length === 0) return '';\n\n  let prefix = strs[0];\n  for (let i = 1; i < strs.length; i++) {\n    while (strs[i].indexOf(prefix) !== 0) {\n      prefix = prefix.substring(0, prefix.length - 1);\n      if (prefix === '') return '';\n    }\n  }\n  return prefix;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n\nconsole.log(longestCommonPrefix(input));",
      "PYTHON": "def longest_common_prefix(strs):\n    if not strs: return \"\"\n\n    prefix = strs[0]\n    for i in range(1, len(strs)):\n        while strs[i].find(prefix) != 0:\n            prefix = prefix[:-1]\n            if not prefix: return \"\"\n    return prefix\n\nimport sys\ninput_lines = sys.stdin.read().strip().split('\\n')\n\nprint(longest_common_prefix(input_lines))",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public static String longestCommonPrefix(String[] strs) {\n        if (strs == null || strs.length == 0) {\n            return \"\";\n        }\n\n        String prefix = strs[0];\n        for (int i = 1; i < strs.length; i++) {\n            while (strs[i].indexOf(prefix) != 0) {\n                prefix = prefix.substring(0, prefix.length() - 1);\n                if (prefix.isEmpty()) {\n                    return \"\";\n                }\n            }\n        }\n        return prefix;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.useDelimiter(\"\\n\").next();\n        String[] strs = line.split(\"\\n\");\n        System.out.println(longestCommonPrefix(strs));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst strs = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n\nif (strs.length === 0) {\n  console.log('');\n} else {\n  let prefix = strs[0];\n  for (let i = 1; i < strs.length; i++) {\n    while (strs[i].indexOf(prefix) !== 0) {\n      prefix = prefix.substring(0, prefix.length - 1);\n      if (prefix === '') {\n        console.log('');\n        process.exit(0);\n      }\n    }\n  }\n  console.log(prefix);\n}",
      "PYTHON": "import sys\nstrs = sys.stdin.read().strip().split('\\n')\n\nif not strs:\n    print(\"\")\nelse:\n    prefix = strs[0]\n    for i in range(1, len(strs)):\n        while strs[i].find(prefix) != 0:\n            prefix = prefix[:-1]\n            if not prefix:\n                print(\"\")\n                sys.exit(0)\n    print(prefix)",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.useDelimiter(\"\\n\").next();\n        String[] strs = line.split(\"\\n\");\n\n        if (strs == null || strs.length == 0) {\n            System.out.println(\"\");\n            return;\n        }\n\n        String prefix = strs[0];\n        for (int i = 1; i < strs.length; i++) {\n            while (strs[i].indexOf(prefix) != 0) {\n                prefix = prefix.substring(0, prefix.length() - 1);\n                if (prefix.isEmpty()) {\n                    System.out.println(\"\");\n                    return;\n                }\n            }\n        }\n        System.out.println(prefix);\n    }\n}"
    },
    "editorial": "The longest common prefix can be found by taking the first string as an initial prefix. Then, iterate through the remaining strings. For each string, repeatedly shorten the `prefix` from its end until it becomes a prefix of the current string. If the `prefix` becomes empty at any point, there is no common prefix among all strings. Otherwise, the final `prefix` will be the longest common prefix."
  },
  
  {
    "title": "Valid Parentheses",
    "description": "Given a string `s` containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. 3. Every close bracket has a corresponding open bracket of the same type.",
    "difficulty": "HARD",
    "tags": ["strings", "stack"],
    "examples": {
      "PYTHON": {
        "input": "()[]{}",
        "output": "True",
        "explanation": "All brackets are properly closed in order."
      },
      "JAVASCRIPT": {
        "input": "([{}])",
        "output": "True",
        "explanation": "Nested brackets are correctly closed."
      },
      "JAVA": {
        "input": "({[",
        "output": "False",
        "explanation": "Open brackets are not closed."
      }
    },
    "constraints": "1 <= s.length <= 10^4. s consists of parentheses only '()[]{}'.",
    "hints": "Use a stack to keep track of open brackets. When a closing bracket is encountered, check the top of the stack.",
    "testCases": [
      {
        "input": "{[]}",
        "output": "True"
      },
      {
        "input": "([)]",
        "output": "False"
      },
      {
        "input": "",
        "output": "True"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction isValid(s) {\n  const stack = [];\n  const map = {\n    '(': ')',\n    '[': ']',\n    '{': '}'\n  };\n\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (map[char]) { // If it's an opening bracket\n      stack.push(char);\n    } else { // If it's a closing bracket\n      if (stack.length === 0) return false; // No matching opening bracket\n      const lastOpen = stack.pop();\n      if (map[lastOpen] !== char) {\n        return false; // Mismatched brackets\n      }\n    }\n  }\n  return stack.length === 0; // All open brackets must be closed\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\n\nconsole.log(isValid(input));",
      "PYTHON": "def is_valid(s):\n    stack = []\n    mapping = {\")\": \"(\", \"]\": \"[\", \"}\": \"{\"-}\n\n    for char in s:\n        if char in mapping.values(): # If it's an opening bracket\n            stack.append(char)\n        elif char in mapping: # If it's a closing bracket\n            if not stack or mapping[char] != stack.pop():\n                return False\n        else:\n            return False # Invalid character\n    return not stack # True if stack is empty\n\nimport sys\ninput_line = sys.stdin.read().strip()\n\nprint(is_valid(input_line))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Stack;\nimport java.util.HashMap;\n\npublic class Main {\n    public static boolean isValid(String s) {\n        Stack<Character> stack = new Stack<>();\n        HashMap<Character, Character> map = new HashMap<>();\n        map.put(')', '(');\n        map.put(']', '[');\n        map.put('}', '{');\n\n        for (char c : s.toCharArray()) {\n            if (map.containsKey(c)) { // It's a closing bracket\n                char topElement = stack.empty() ? '#' : stack.pop();\n                if (topElement != map.get(c)) {\n                    return false;\n                }\n            } else { // It's an opening bracket\n                stack.push(c);\n            }\n        }\n        return stack.empty();\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.nextLine();\n        System.out.println(isValid(s));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst s = fs.readFileSync(0, 'utf-8').trim();\n\nconst stack = [];\nconst map = {\n  '(': ')',\n  '[': ']',\n  '{': '}'\n};\n\nlet isValidString = true;\nfor (let i = 0; i < s.length; i++) {\n  const char = s[i];\n  if (map[char]) {\n    stack.push(char);\n  } else {\n    if (stack.length === 0) {\n      isValidString = false;\n      break;\n    }\n    const lastOpen = stack.pop();\n    if (map[lastOpen] !== char) {\n      isValidString = false;\n      break;\n    }\n  }\n}\n\nif (stack.length !== 0) {\n  isValidString = false;\n}\n\nconsole.log(isValidString);",
      "PYTHON": "import sys\ns = sys.stdin.read().strip()\n\nstack = []\nmapping = {\")\": \"(\", \"]\": \"[\", \"}\": \"{\"-}\n\nis_valid_str = True\nfor char in s:\n    if char in mapping.values():\n        stack.append(char)\n    elif char in mapping:\n        if not stack or mapping[char] != stack.pop():\n            is_valid_str = False\n            break\n    else:\n        is_valid_str = False\n        break\n\nif stack:\n    is_valid_str = False\n\nprint(is_valid_str)",
      "JAVA": "import java.util.Scanner;\nimport java.util.Stack;\nimport java.util.HashMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.nextLine();\n\n        Stack<Character> stack = new Stack<>();\n        HashMap<Character, Character> map = new HashMap<>();\n        map.put(')', '(');\n        map.put(']', '[');\n        map.put('}', '{');\n\n        boolean isValid = true;\n        for (char c : s.toCharArray()) {\n            if (map.containsKey(c)) {\n                char topElement = stack.empty() ? '#' : stack.pop();\n                if (topElement != map.get(c)) {\n                    isValid = false;\n                    break;\n                }\n            } else {\n                stack.push(c);\n            }\n        }\n        if (!stack.empty()) {\n            isValid = false;\n        }\n\n        System.out.println(isValid);\n    }\n}"
    },
    "editorial": "This problem is a classic application of a stack. Iterate through the string. If an opening bracket is encountered, push it onto the stack. If a closing bracket is encountered, check if the stack is empty (meaning no corresponding opening bracket) or if the top of the stack does not match the type of the closing bracket. If either condition is true, the string is invalid. Otherwise, pop the matching opening bracket from the stack. After iterating through the entire string, if the stack is empty, all brackets were validly closed; otherwise, some opening brackets were not closed."
  },
  
  {
    "title": "Implement Queue using Stacks",
    "description": "Implement a first in, first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (`push`, `peek`, `pop`, and `empty`).",
    "difficulty": "HARD",
    "tags": ["data-structures", "stack", "queue"],
    "examples": {
      "PYTHON": {
        "input": "push 1\npush 2\npeek\npop\nempty",
        "output": "1\nFalse",
        "explanation": "Operations demonstrate queue behavior."
      },
      "JAVASCRIPT": {
        "input": "push 5\npush 10\npop\npeek",
        "output": "5\n10",
        "explanation": "Shows push, pop, and peek functionality."
      },
      "JAVA": {
        "input": "empty\npush 7\nempty",
        "output": "True\nFalse",
        "explanation": "Demonstrates empty checks."
      }
    },
    "constraints": "1 <= x <= 10^9 for push. At most 100 calls will be made to push, pop, peek, and empty. All calls to pop and peek are valid (i.e., a queue will not be empty when pop or peek is called).",
    "hints": "Use one stack for pushing elements (input stack) and another for popping/peeking (output stack). When the output stack is empty and a pop/peek operation is requested, transfer all elements from the input stack to the output stack.",
    "testCases": [
      {
        "input": "push 1\npush 2\npeek\npop\npeek",
        "output": "1\n2"
      },
      {
        "input": "push 100\npop\nempty",
        "output": "100\nTrue"
      },
      {
        "input": "push 1\npush 2\npop\npush 3\npeek",
        "output": "1\n3"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nclass MyQueue {\n  constructor() {\n    this.inStack = [];\n    this.outStack = [];\n  }\n\n  push(x) {\n    this.inStack.push(x);\n  }\n\n  _transfer() {\n    if (this.outStack.length === 0) {\n      while (this.inStack.length > 0) {\n        this.outStack.push(this.inStack.pop());\n      }\n    }\n  }\n\n  pop() {\n    this._transfer();\n    return this.outStack.pop();\n  }\n\n  peek() {\n    this._transfer();\n    return this.outStack[this.outStack.length - 1];\n  }\n\n  empty() {\n    return this.inStack.length === 0 && this.outStack.length === 0;\n  }\n}\n\nconst operations = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst queue = new MyQueue();\nconst results = [];\n\nfor (const op of operations) {\n  const [command, value] = op.split(' ');\n  if (command === 'push') {\n    queue.push(parseInt(value));\n  } else if (command === 'pop') {\n    results.push(queue.pop());\n  } else if (command === 'peek') {\n    results.push(queue.peek());\n  } else if (command === 'empty') {\n    results.push(queue.empty());\n  }\n}\n\nconsole.log(results.join('\\n'));",
      "PYTHON": "class MyQueue:\n    def __init__(self):\n        self.in_stack = []\n        self.out_stack = []\n\n    def push(self, x: int) -> None:\n        self.in_stack.append(x)\n\n    def _transfer(self):\n        if not self.out_stack:\n            while self.in_stack:\n                self.out_stack.append(self.in_stack.pop())\n\n    def pop(self) -> int:\n        self._transfer()\n        return self.out_stack.pop()\n\n    def peek(self) -> int:\n        self._transfer()\n        return self.out_stack[-1]\n\n    def empty(self) -> bool:\n        return not self.in_stack and not self.out_stack\n\nimport sys\noperations = sys.stdin.read().strip().split('\\n')\n\nqueue = MyQueue()\nresults = []\n\nfor op in operations:\n    parts = op.split()\n    command = parts[0]\n    if command == 'push':\n        value = int(parts[1])\n        queue.push(value)\n    elif command == 'pop':\n        results.append(str(queue.pop()))\n    elif command == 'peek':\n        results.append(str(queue.peek()))\n    elif command == 'empty':\n        results.append(str(queue.empty()))\n\nprint('\\n'.join(results))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Stack;\nimport java.util.ArrayList;\n\nclass MyQueue {\n    private Stack<Integer> inStack;\n    private Stack<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new Stack<>();\n        outStack = new Stack<>();\n    }\n\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    private void transfer() {\n        if (outStack.empty()) {\n            while (!inStack.empty()) {\n                outStack.push(inStack.pop());\n            }\n        }\n    }\n\n    public int pop() {\n        transfer();\n        return outStack.pop();\n    }\n\n    public int peek() {\n        transfer();\n        return outStack.peek();\n    }\n\n    public boolean empty() {\n        return inStack.empty() && outStack.empty();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        ArrayList<String> operationLines = new ArrayList<>();\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            operationLines.add(line);\n        }\n\n        MyQueue queue = new MyQueue();\n        ArrayList<String> results = new ArrayList<>();\n\n        for (String op : operationLines) {\n            String[] parts = op.split(\" \");\n            String command = parts[0];\n            if (command.equals(\"push\")) {\n                int value = Integer.parseInt(parts[1]);\n                queue.push(value);\n            } else if (command.equals(\"pop\")) {\n                results.add(String.valueOf(queue.pop()));\n            } else if (command.equals(\"peek\")) {\n                results.add(String.valueOf(queue.peek()));\n            } else if (command.equals(\"empty\")) {\n                results.add(String.valueOf(queue.empty()));\n            }\n        }\n\n        for (String res : results) {\n            System.out.println(res);\n        }\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nclass MyQueue {\n  constructor() {\n    this.inStack = [];\n    this.outStack = [];\n  }\n\n  push(x) {\n    this.inStack.push(x);\n  }\n\n  _transfer() {\n    if (this.outStack.length === 0) {\n      while (this.inStack.length > 0) {\n        this.outStack.push(this.inStack.pop());\n      }\n    }\n  }\n\n  pop() {\n    this._transfer();\n    return this.outStack.pop();\n  }\n\n  peek() {\n    this._transfer();\n    return this.outStack[this.outStack.length - 1];\n  }\n\n  empty() {\n    return this.inStack.length === 0 && this.outStack.length === 0;\n  }\n}\n\nconst operations = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst queue = new MyQueue();\nconst results = [];\n\nfor (const op of operations) {\n  const [command, value] = op.split(' ');\n  if (command === 'push') {\n    queue.push(parseInt(value));\n  } else if (command === 'pop') {\n    results.push(queue.pop());\n  } else if (command === 'peek') {\n    results.push(queue.peek());\n  } else if (command === 'empty') {\n    results.push(queue.empty());\n  }\n}\n\nconsole.log(results.join('\\n'));",
      "PYTHON": "class MyQueue:\n    def __init__(self):\n        self.in_stack = []\n        self.out_stack = []\n\n    def push(self, x: int) -> None:\n        self.in_stack.append(x)\n\n    def _transfer(self):\n        if not self.out_stack:\n            while self.in_stack:\n                self.out_stack.append(self.in_stack.pop())\n\n    def pop(self) -> int:\n        self._transfer()\n        return self.out_stack.pop()\n\n    def peek(self) -> int:\n        self._transfer()\n        return self.out_stack[-1]\n\n    def empty(self) -> bool:\n        return not self.in_stack and not self.out_stack\n\nimport sys\noperations = sys.stdin.read().strip().split('\\n')\n\nqueue = MyQueue()\nresults = []\n\nfor op in operations:\n    parts = op.split()\n    command = parts[0]\n    if command == 'push':\n        value = int(parts[1])\n        queue.push(value)\n    elif command == 'pop':\n        results.append(str(queue.pop()))\n    elif command == 'peek':\n        results.append(str(queue.peek()))\n    elif command == 'empty':\n        results.append(str(queue.empty()))\n\nprint('\\n'.join(results))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Stack;\nimport java.util.ArrayList;\n\nclass MyQueue {\n    private Stack<Integer> inStack;\n    private Stack<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new Stack<>();\n        outStack = new Stack<>();\n    }\n\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    private void transfer() {\n        if (outStack.empty()) {\n            while (!inStack.empty()) {\n                outStack.push(inStack.pop());\n            }\n        }\n    }\n\n    public int pop() {\n        transfer();\n        return outStack.pop();\n    }\n\n    public int peek() {\n        transfer();\n        return outStack.peek();\n    }\n\n    public boolean empty() {\n        return inStack.empty() && outStack.empty();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        ArrayList<String> operationLines = new ArrayList<>();\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            operationLines.add(line);\n        }\n\n        MyQueue queue = new MyQueue();\n        ArrayList<String> results = new ArrayList<>();\n\n        for (String op : operationLines) {\n            String[] parts = op.split(\" \");\n            String command = parts[0];\n            if (command.equals(\"push\")) {\n                int value = Integer.parseInt(parts[1]);\n                queue.push(value);\n            } else if (command.equals(\"pop\")) {\n                results.add(String.valueOf(queue.pop()));\n            } else if (command.equals(\"peek\")) {\n                results.add(String.valueOf(queue.peek()));\n            } else if (command.equals(\"empty\")) {\n                results.add(String.valueOf(queue.empty()));\n            }\n        }\n\n        for (String res : results) {\n            System.out.println(res);\n        }\n    }\n}"
    },
    "editorial": "To implement a queue using two stacks, use one stack (`inStack`) for `push` operations and another (`outStack`) for `pop` and `peek` operations. When a `pop` or `peek` is called and `outStack` is empty, transfer all elements from `inStack` to `outStack` by popping from `inStack` and pushing onto `outStack`. This reverses the order, ensuring FIFO. If `outStack` is not empty, simply perform the operation on `outStack`. The `empty` method checks if both stacks are empty."
  },
  
  {
    "title": "Reverse a Linked List",
    "description": "Given the `head` of a singly linked list, reverse the list, and return the reversed list.",
    "difficulty": "HARD",
    "tags": ["linked-list", "pointers", "recursion"],
    "examples": {
      "PYTHON": {
        "input": "1->2->3->4->5",
        "output": "5->4->3->2->1",
        "explanation": "The linked list is reversed."
      },
      "JAVASCRIPT": {
        "input": "1->2",
        "output": "2->1",
        "explanation": "The linked list is reversed."
      },
      "JAVA": {
        "input": "null",
        "output": "null",
        "explanation": "An empty list remains empty."
      }
    },
    "constraints": "The number of nodes in the list is in the range [0, 5000]. -5000 <= Node.val <= 5000.",
    "hints": "Iterate through the list, changing the `next` pointer of each node to point to its previous node. Keep track of the `previous` and `current` nodes.",
    "testCases": [
      {
        "input": "7",
        "output": "7"
      },
      {
        "input": "1->2->3",
        "output": "3->2->1"
      },
      {
        "input": "1->null",
        "output": "1->null"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nclass ListNode {\n  constructor(val, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction reverseList(head) {\n  let prev = null;\n  let current = head;\n  while (current !== null) {\n    let nextTemp = current.next; // Store next node\n    current.next = prev;        // Reverse current node's pointer\n    prev = current;             // Move prev to current\n    current = nextTemp;         // Move current to next\n  }\n  return prev;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\nlet head = null;\nif (input !== 'null' && input.length > 0) {\n  const values = input.split('->').map(Number);\n  head = new ListNode(values[0]);\n  let current = head;\n  for (let i = 1; i < values.length; i++) {\n    current.next = new ListNode(values[i]);\n    current = current.next;\n  }\n}\n\nconst reversedHead = reverseList(head);\n\nlet result = '';\nlet current = reversedHead;\nwhile (current !== null) {\n  result += current.val;\n  if (current.next !== null) {\n    result += '->';\n  }\n  current = current.next;\n}\nconsole.log(result === '' ? 'null' : result);",
      "PYTHON": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverse_list(head: ListNode) -> ListNode:\n    prev = None\n    current = head\n    while current:\n        next_temp = current.next\n        current.next = prev\n        prev = current\n        current = next_temp\n    return prev\n\nimport sys\n\ninput_str = sys.stdin.read().strip()\nhead = None\nif input_str != 'null' and len(input_str) > 0:\n    values = list(map(int, input_str.split('->')))\n    head = ListNode(values[0])\n    current = head\n    for i in range(1, len(values)):\n        current.next = ListNode(values[i])\n        current = current.next\n\nreversed_head = reverse_list(head)\n\nresult = []\ncurrent = reversed_head\nwhile current:\n    result.append(str(current.val))\n    current = current.next\n\nprint('->'.join(result) if result else 'null')",
      "JAVA": "import java.util.Scanner;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\npublic class Main {\n    public static ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode current = head;\n        while (current != null) {\n            ListNode nextTemp = current.next;\n            current.next = prev;\n            prev = current;\n            current = nextTemp;\n        }\n        return prev;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        ListNode head = null;\n        if (!line.equals(\"null\") && !line.isEmpty()) {\n            String[] parts = line.split(\"->\");\n            head = new ListNode(Integer.parseInt(parts[0]));\n            ListNode current = head;\n            for (int i = 1; i < parts.length; i++) {\n                current.next = new ListNode(Integer.parseInt(parts[i]));\n                current = current.next;\n            }\n        }\n\n        ListNode reversedHead = reverseList(head);\n\n        StringBuilder sb = new StringBuilder();\n        ListNode current = reversedHead;\n        while (current != null) {\n            sb.append(current.val);\n            if (current.next != null) {\n                sb.append(\"->\");\n            }\n            current = current.next;\n        }\n        System.out.println(sb.length() == 0 ? \"null\" : sb.toString());\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nclass ListNode {\n  constructor(val, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\nlet head = null;\nif (input !== 'null' && input.length > 0) {\n  const values = input.split('->').map(Number);\n  head = new ListNode(values[0]);\n  let current = head;\n  for (let i = 1; i < values.length; i++) {\n    current.next = new ListNode(values[i]);\n    current = current.next;\n  }\n}\n\nlet prev = null;\nlet current = head;\nwhile (current !== null) {\n  let nextTemp = current.next;\n  current.next = prev;\n  prev = current;\n  current = nextTemp;\n}\n\nlet result = '';\nlet reversedHead = prev;\ncurrent = reversedHead;\nwhile (current !== null) {\n  result += current.val;\n  if (current.next !== null) {\n    result += '->';\n  }\n  current = current.next;\n}\nconsole.log(result === '' ? 'null' : result);",
      "PYTHON": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nimport sys\n\ninput_str = sys.stdin.read().strip()\nhead = None\nif input_str != 'null' and len(input_str) > 0:\n    values = list(map(int, input_str.split('->')))\n    head = ListNode(values[0])\n    current = head\n    for i in range(1, len(values)):\n        current.next = ListNode(values[i])\n        current = current.next\n\nprev = None\ncurrent = head\nwhile current:\n    next_temp = current.next\n    current.next = prev\n    prev = current\n    current = next_temp\n\nreversed_head = prev\nresult = []\ncurrent = reversed_head\nwhile current:\n    result.append(str(current.val))\n    current = current.next\n\nprint('->'.join(result) if result else 'null')",
      "JAVA": "import java.util.Scanner;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        ListNode head = null;\n        if (!line.equals(\"null\") && !line.isEmpty()) {\n            String[] parts = line.split(\"->\");\n            head = new ListNode(Integer.parseInt(parts[0]));\n            ListNode current = head;\n            for (int i = 1; i < parts.length; i++) {\n                current.next = new ListNode(Integer.parseInt(parts[i]));\n                current = current.next;\n            }\n        }\n\n        ListNode prev = null;\n        ListNode current = head;\n        while (current != null) {\n            ListNode nextTemp = current.next;\n            current.next = prev;\n            prev = current;\n            current = nextTemp;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        ListNode reversedHead = prev;\n        current = reversedHead;\n        while (current != null) {\n            sb.append(current.val);\n            if (current.next != null) {\n                sb.append(\"->\");\n            }\n            current = current.next;\n        }\n        System.out.println(sb.length() == 0 ? \"null\" : sb.toString());\n    }\n}"
    },
    "editorial": "Reversing a singly linked list typically involves an iterative approach using three pointers: `prev`, `current`, and `nextTemp`. Initialize `prev` to `null` and `current` to `head`. In each iteration, store `current.next` in `nextTemp`, then set `current.next` to `prev`, update `prev` to `current`, and finally move `current` to `nextTemp`. Repeat until `current` becomes `null`. The `prev` pointer will then point to the new head of the reversed list."
  },
  
  {
    "title": "Find Missing Number in a Range",
    "description": "Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return the only number in the range that is missing from the array.",
    "difficulty": "EASY",
    "tags": ["arrays", "maths", "bit-manipulation"],
    "examples": {
      "PYTHON": {
        "input": "3 0 1",
        "output": "2",
        "explanation": "n = 3, so all numbers are in the range [0,3]. 2 is the missing number."
      },
      "JAVASCRIPT": {
        "input": "9 6 4 2 3 5 7 0 1",
        "output": "8",
        "explanation": "n = 9, so all numbers are in the range [0,9]. 8 is the missing number."
      },
      "JAVA": {
        "input": "0 1",
        "output": "2",
        "explanation": "n = 2, so all numbers are in the range [0,2]. 2 is the missing number."
      }
    },
    "constraints": "n == nums.length, 1 <= n <= 10^4. 0 <= nums[i] <= n. All numbers in nums are unique.",
    "hints": "You can use the sum of an arithmetic series formula (n * (n + 1) / 2) or XOR properties.",
    "testCases": [
      {
        "input": "0",
        "output": "1"
      },
      {
        "input": "1",
        "output": "0"
      },
      {
        "input": "0 1 3",
        "output": "2"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction missingNumber(nums) {\n  const n = nums.length;\n  const expectedSum = n * (n + 1) / 2;\n  let actualSum = 0;\n  for (const num of nums) {\n    actualSum += num;\n  }\n  return expectedSum - actualSum;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\nconst nums = input.split(' ').map(Number);\n\nconsole.log(missingNumber(nums));",
      "PYTHON": "def missing_number(nums):\n    n = len(nums)\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum\n\nimport sys\ninput_line = sys.stdin.read().strip()\nnums = list(map(int, input_line.split()))\n\nprint(missing_number(nums))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static int missingNumber(int[] nums) {\n        int n = nums.length;\n        int expectedSum = n * (n + 1) / 2;\n        int actualSum = 0;\n        for (int num : nums) {\n            actualSum += num;\n        }\n        return expectedSum - actualSum;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        int[] nums = Arrays.stream(line.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        System.out.println(missingNumber(nums));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst nums = fs.readFileSync(0, 'utf-8').trim().split(' ').map(Number);\nconst n = nums.length;\nconst expectedSum = n * (n + 1) / 2;\nlet actualSum = 0;\nfor (const num of nums) {\n  actualSum += num;\n}\nconsole.log(expectedSum - actualSum);",
      "PYTHON": "import sys\nnums = list(map(int, sys.stdin.read().strip().split()))\nn = len(nums)\nexpected_sum = n * (n + 1) // 2\nactual_sum = sum(nums)\nprint(expected_sum - actual_sum)",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        int[] nums = Arrays.stream(line.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        int n = nums.length;\n        int expectedSum = n * (n + 1) / 2;\n        int actualSum = 0;\n        for (int num : nums) {\n            actualSum += num;\n        }\n        System.out.println(expectedSum - actualSum);\n    }\n}"
    },
    "editorial": "The problem asks for the missing number in a range `[0, n]`. One efficient way to solve this is to use the sum of an arithmetic series. Calculate the expected sum of all numbers from 0 to `n` using the formula `n * (n + 1) / 2`. Then, calculate the actual sum of the numbers present in the given array. The missing number will be the difference between the expected sum and the actual sum. Another approach is using XOR properties."
  },
  {
    "title": "Rotate Array",
    "description": "Given an integer array `nums`, rotate the array to the right by `k` steps, where `k` is non-negative. Perform the rotation in-place.",
    "difficulty": "MEDIUM",
    "tags": ["arrays", "in-place"],
    "examples": {
      "PYTHON": {
        "input": "1 2 3 4 5 6 7\n3",
        "output": "5 6 7 1 2 3 4",
        "explanation": "Rotating [1,2,3,4,5,6,7] by 3 steps results in [5,6,7,1,2,3,4]."
      },
      "JAVASCRIPT": {
        "input": "-1 -100 3 99\n2",
        "output": "3 99 -1 -100",
        "explanation": "Rotating [-1,-100,3,99] by 2 steps results in [3,99,-1,-100]."
      },
      "JAVA": {
        "input": "1 2\n0",
        "output": "1 2",
        "explanation": "Rotating by 0 steps results in no change."
      }
    },
    "constraints": "1 <= nums.length <= 10^5, -2^31 <= nums[i] <= 2^31 - 1, 0 <= k <= 10^5",
    "hints": "Consider using a temporary array, or multiple reversals to achieve in-place rotation.",
    "testCases": [
      {
        "input": "1 2 3\n1",
        "output": "3 1 2"
      },
      {
        "input": "1 2 3 4 5\n5",
        "output": "1 2 3 4 5"
      },
      {
        "input": "1 2 3 4\n7",
        "output": "2 3 4 1"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction rotate(nums, k) {\n  k %= nums.length; // Handle k larger than array length\n\n  const reverse = (arr, start, end) => {\n    while (start < end) {\n      [arr[start], arr[end]] = [arr[end], arr[start]];\n      start++;\n      end--;\n    }\n  };\n\n  reverse(nums, 0, nums.length - 1);    // Reverse entire array\n  reverse(nums, 0, k - 1);            // Reverse first k elements\n  reverse(nums, k, nums.length - 1);  // Reverse remaining elements\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst nums = input[0].split(' ').map(Number);\nconst k = parseInt(input[1]);\n\nrotate(nums, k);\nconsole.log(nums.join(' '));",
      "PYTHON": "def rotate(nums: list[int], k: int) -> None:\n    n = len(nums)\n    k %= n\n\n    def reverse(arr, start, end):\n        while start < end:\n            arr[start], arr[end] = arr[end], arr[start]\n            start += 1\n            end -= 1\n    \n    reverse(nums, 0, n - 1)\n    reverse(nums, 0, k - 1)\n    reverse(nums, k, n - 1)\n\nimport sys\ninput_lines = sys.stdin.read().strip().split('\\n')\nnums = list(map(int, input_lines[0].split()))\nk = int(input_lines[1])\n\nrotate(nums, k)\nprint(*nums)",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void rotate(int[] nums, int k) {\n        k %= nums.length;\n\n        reverse(nums, 0, nums.length - 1);\n        reverse(nums, 0, k - 1);\n        reverse(nums, k, nums.length - 1);\n    }\n\n    private static void reverse(int[] nums, int start, int end) {\n        while (start < end) {\n            int temp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++;\n            end--;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line1 = sc.nextLine();\n        int[] nums = Arrays.stream(line1.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        int k = sc.nextInt();\n\n        rotate(nums, k);\n        System.out.println(Arrays.stream(nums).mapToObj(String::valueOf).collect(Collectors.joining(\" \")));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst nums = input[0].split(' ').map(Number);\nconst k = parseInt(input[1]);\n\nconst n = nums.length;\nconst actualK = k % n;\n\nconst reverse = (arr, start, end) => {\n  while (start < end) {\n    [arr[start], arr[end]] = [arr[end], arr[start]];\n    start++;\n    end--;\n  }\n};\n\nreverse(nums, 0, n - 1);\nreverse(nums, 0, actualK - 1);\nreverse(nums, actualK, n - 1);\n\nconsole.log(nums.join(' '));",
      "PYTHON": "import sys\ninput_lines = sys.stdin.read().strip().split('\\n')\nnums = list(map(int, input_lines[0].split()))\nk = int(input_lines[1])\n\nn = len(nums)\nactual_k = k % n\n\ndef reverse(arr, start, end):\n    while start < end:\n        arr[start], arr[end] = arr[end], arr[start]\n        start += 1\n        end -= 1\n    \nreverse(nums, 0, n - 1)\nreverse(nums, 0, actual_k - 1)\nreverse(nums, actual_k, n - 1)\n\nprint(*nums)",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    private static void reverse(int[] nums, int start, int end) {\n        while (start < end) {\n            int temp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++;\n            end--;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line1 = sc.nextLine();\n        int[] nums = Arrays.stream(line1.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        int k = sc.nextInt();\n\n        int n = nums.length;\n        k %= n;\n\n        reverse(nums, 0, n - 1);\n        reverse(nums, 0, k - 1);\n        reverse(nums, k, n - 1);\n\n        System.out.println(Arrays.stream(nums).mapToObj(String::valueOf).collect(Collectors.joining(\" \")));\n    }\n}"
    },
    "editorial": "To rotate an array right by `k` steps in-place, an efficient method involves three reversals: 1. Reverse the entire array. 2. Reverse the first `k` elements. 3. Reverse the remaining `n - k` elements. Remember to handle cases where `k` is larger than the array length by using `k % nums.length`."
  },
  {
    "title": "Container With Most Water",
    "description": "You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `i`th line are `(i, 0)` and `(i, height[i])`. Find two such lines that, together with the x-axis, form a container, such that the container contains the most water. Return the maximum amount of water a container can store. Notice that you may not slant the container.",
    "difficulty": "HARD",
    "tags": ["arrays", "two-pointers", "greedy"],
    "examples": {
      "PYTHON": {
        "input": "1 8 6 2 5 4 8 3 7",
        "output": "49",
        "explanation": "The maximum area is 49 (between lines at index 1 and 8, heights 8 and 7)."
      },
      "JAVASCRIPT": {
        "input": "1 1",
        "output": "1",
        "explanation": "The maximum area is 1 (between lines at index 0 and 1, heights 1 and 1)."
      },
      "JAVA": {
        "input": "4 3 2 1 4",
        "output": "16",
        "explanation": "The maximum area is 16 (between lines at index 0 and 4, heights 4 and 4)."
      }
    },
    "constraints": "n == height.length, 2 <= n <= 10^5, 0 <= height[i] <= 10^4",
    "hints": "Use two pointers, one at each end of the array. Move the pointer pointing to the shorter line inward.",
    "testCases": [
      {
        "input": "1 2 1",
        "output": "2"
      },
      {
        "input": "2 3 4 5 18 17 6",
        "output": "17"
      },
      {
        "input": "0 0 0 0",
        "output": "0"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction maxArea(height) {\n  let maxWater = 0;\n  let left = 0;\n  let right = height.length - 1;\n\n  while (left < right) {\n    const currentHeight = Math.min(height[left], height[right]);\n    const width = right - left;\n    maxWater = Math.max(maxWater, currentHeight * width);\n\n    if (height[left] < height[right]) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n  return maxWater;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\nconst height = input.split(' ').map(Number);\n\nconsole.log(maxArea(height));",
      "PYTHON": "def max_area(height: list[int]) -> int:\n    max_water = 0\n    left = 0\n    right = len(height) - 1\n\n    while left < right:\n        current_height = min(height[left], height[right])\n        width = right - left\n        max_water = max(max_water, current_height * width)\n\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_water\n\nimport sys\ninput_line = sys.stdin.read().strip()\nheight = list(map(int, input_line.split()))\n\nprint(max_area(height))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static int maxArea(int[] height) {\n        int maxWater = 0;\n        int left = 0;\n        int right = height.length - 1;\n\n        while (left < right) {\n            int currentHeight = Math.min(height[left], height[right]);\n            int width = right - left;\n            maxWater = Math.max(maxWater, currentHeight * width);\n\n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return maxWater;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        int[] height = Arrays.stream(line.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        System.out.println(maxArea(height));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst height = fs.readFileSync(0, 'utf-8').trim().split(' ').map(Number);\n\nlet maxWater = 0;\nlet left = 0;\nlet right = height.length - 1;\n\nwhile (left < right) {\n  const currentHeight = Math.min(height[left], height[right]);\n  const width = right - left;\n  maxWater = Math.max(maxWater, currentHeight * width);\n\n  if (height[left] < height[right]) {\n    left++;\n  } else {\n    right--;\n  }\n}\nconsole.log(maxWater);",
      "PYTHON": "import sys\nheight = list(map(int, sys.stdin.read().strip().split()))\n\nmax_water = 0\nleft = 0\nright = len(height) - 1\n\nwhile left < right:\n    current_height = min(height[left], height[right])\n    width = right - left\n    max_water = max(max_water, current_height * width)\n\n    if height[left] < height[right]:\n        left += 1\n    else:\n        right -= 1\nprint(max_water)",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        int[] height = Arrays.stream(line.split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n        int maxWater = 0;\n        int left = 0;\n        int right = height.length - 1;\n\n        while (left < right) {\n            int currentHeight = Math.min(height[left], height[right]);\n            int width = right - left;\n            maxWater = Math.max(maxWater, currentHeight * width);\n\n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        System.out.println(maxWater);\n    }\n}"
    },
    "editorial": "This problem can be solved using the two-pointer technique. Initialize two pointers, one at the beginning (`left`) and one at the end (`right`) of the `height` array. Calculate the area between these two pointers (which is `min(height[left], height[right]) * (right - left)`) and update the `maxWater` found so far. To maximize the area, you should move the pointer that points to the shorter line inward, as moving the taller line's pointer will either decrease or keep the same height, while the width decreases. Continue until the pointers meet."
  },
  {
    "title": "Fibonacci Sequence",
    "description": "Given a non-negative integer `n`, return the `n`-th Fibonacci number. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. (i.e., F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) for n > 1).",
    "difficulty": "EASY",
    "tags": ["maths", "recursion", "dynamic-programming"],
    "examples": {
      "PYTHON": {
        "input": "5",
        "output": "5",
        "explanation": "F(5) = F(4) + F(3) = 3 + 2 = 5."
      },
      "JAVASCRIPT": {
        "input": "0",
        "output": "0",
        "explanation": "The 0th Fibonacci number is 0."
      },
      "JAVA": {
        "input": "10",
        "output": "55",
        "explanation": "The 10th Fibonacci number is 55."
      }
    },
    "constraints": "0 <= n <= 45 (to fit in standard integer types for common approaches)",
    "hints": "You can solve this using recursion, iteration, or dynamic programming with memoization.",
    "testCases": [
      {
        "input": "1",
        "output": "1"
      },
      {
        "input": "2",
        "output": "1"
      },
      {
        "input": "7",
        "output": "13"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction fib(n) {\n  if (n <= 1) {\n    return n;\n  }\n  let a = 0;\n  let b = 1;\n  for (let i = 2; i <= n; i++) {\n    let temp = a + b;\n    a = b;\n    b = temp;\n  }\n  return b;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\nconst n = parseInt(input);\n\nconsole.log(fib(n));",
      "PYTHON": "def fib(n: int) -> int:\n    if n <= 1:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\nimport sys\ninput_line = sys.stdin.read().strip()\nn = int(input_line)\n\nprint(fib(n))",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public static int fib(int n) {\n        if (n <= 1) {\n            return n;\n        }\n        int a = 0;\n        int b = 1;\n        for (int i = 2; i <= n; i++) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        return b;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        System.out.println(fib(n));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst n = parseInt(fs.readFileSync(0, 'utf-8').trim());\n\nif (n <= 1) {\n  console.log(n);\n} else {\n  let a = 0;\n  let b = 1;\n  for (let i = 2; i <= n; i++) {\n    let temp = a + b;\n    a = b;\n    b = temp;\n  }\n  console.log(b);\n}",
      "PYTHON": "import sys\nn = int(sys.stdin.read().strip())\n\nif n <= 1:\n    print(n)\nelse:\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    print(b)",
      "JAVA": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        if (n <= 1) {\n            System.out.println(n);\n        } else {\n            int a = 0;\n            int b = 1;\n            for (int i = 2; i <= n; i++) {\n                int temp = a + b;\n                a = b;\n                b = temp;\n            }\n            System.out.println(b);\n        }\n    }\n}"
    },
    "editorial": "The Fibonacci sequence can be computed iteratively. Initialize two variables, say `a = 0` and `b = 1`. Then, loop from 2 up to `n`. In each iteration, calculate the next Fibonacci number as the sum of `a` and `b`, then update `a` to `b` and `b` to the newly calculated sum. The value of `b` after the loop will be the `n`-th Fibonacci number. Base cases for n=0 and n=1 should be handled separately."
  },
  {
    "title": "Intersection of Two Arrays II",
    "description": "Given two integer arrays `nums1` and `nums2`, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.",
    "difficulty": "MEDIUM",
    "tags": ["arrays", "hashmaps", "sorting"],
    "examples": {
      "PYTHON": {
        "input": "1 2 2 1\n2 2",
        "output": "2 2",
        "explanation": "The common elements are 2, which appears twice in both."
      },
      "JAVASCRIPT": {
        "input": "4 9 5\n9 4 9 8 4",
        "output": "4 9",
        "explanation": "The common elements are 4 and 9. Order doesn't matter, and 4 appears once, 9 appears once in the output because that's their minimum frequency in both."
      },
      "JAVA": {
        "input": "1 2 3\n4 5 6",
        "output": "",
        "explanation": "No common elements."
      }
    },
    "constraints": "1 <= nums1.length, nums2.length <= 1000, 0 <= nums1[i], nums2[i] <= 1000",
    "hints": "Use a hash map to store frequencies of elements in one array, then iterate through the second array.",
    "testCases": [
      {
        "input": "1\n1",
        "output": "1"
      },
      {
        "input": "2 2\n1 2 2 3",
        "output": "2 2"
      },
      {
        "input": "7 7 7\n7 7",
        "output": "7 7"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction intersect(nums1, nums2) {\n  const freqMap = new Map();\n  for (const num of nums1) {\n    freqMap.set(num, (freqMap.get(num) || 0) + 1);\n  }\n\n  const result = [];\n  for (const num of nums2) {\n    if (freqMap.has(num) && freqMap.get(num) > 0) {\n      result.push(num);\n      freqMap.set(num, freqMap.get(num) - 1);\n    }\n  }\n  return result;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst nums1 = input[0].split(' ').map(Number);\nconst nums2 = input[1].split(' ').map(Number);\n\nconsole.log(intersect(nums1, nums2).join(' '));",
      "PYTHON": "from collections import Counter\nimport sys\n\ndef intersect(nums1: list[int], nums2: list[int]) -> list[int]:\n    freq_map = Counter(nums1)\n    result = []\n    for num in nums2:\n        if num in freq_map and freq_map[num] > 0:\n            result.append(num)\n            freq_map[num] -= 1\n    return result\n\ninput_lines = sys.stdin.read().strip().split('\\n')\nnums1 = list(map(int, input_lines[0].split()))\nnums2 = list(map(int, input_lines[1].split()))\n\nprint(*intersect(nums1, nums2))",
      "JAVA": "import java.util.Scanner;\nimport java.util.HashMap;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static int[] intersect(int[] nums1, int[] nums2) {\n        HashMap<Integer, Integer> freqMap = new HashMap<>();\n        for (int num : nums1) {\n            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);\n        }\n\n        ArrayList<Integer> resultList = new ArrayList<>();\n        for (int num : nums2) {\n            if (freqMap.containsKey(num) && freqMap.get(num) > 0) {\n                resultList.add(num);\n                freqMap.put(num, freqMap.get(num) - 1);\n            }\n        }\n\n        int[] result = new int[resultList.size()];\n        for (int i = 0; i < resultList.size(); i++) {\n            result[i] = resultList.get(i);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line1 = sc.nextLine();\n        String line2 = sc.nextLine();\n\n        int[] nums1 = Arrays.stream(line1.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        int[] nums2 = Arrays.stream(line2.split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n        int[] result = intersect(nums1, nums2);\n        System.out.println(Arrays.stream(result).mapToObj(String::valueOf).collect(Collectors.joining(\" \")));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst nums1 = input[0].split(' ').map(Number);\nconst nums2 = input[1].split(' ').map(Number);\n\nconst freqMap = new Map();\nfor (const num of nums1) {\n  freqMap.set(num, (freqMap.get(num) || 0) + 1);\n}\n\nconst result = [];\nfor (const num of nums2) {\n  if (freqMap.has(num) && freqMap.get(num) > 0) {\n    result.push(num);\n    freqMap.set(num, freqMap.get(num) - 1);\n  }\n}\nconsole.log(result.join(' '));",
      "PYTHON": "from collections import Counter\nimport sys\n\ninput_lines = sys.stdin.read().strip().split('\\n')\nnums1 = list(map(int, input_lines[0].split()))\nnums2 = list(map(int, input_lines[1].split()))\n\nfreq_map = Counter(nums1)\nresult = []\nfor num in nums2:\n    if num in freq_map and freq_map[num] > 0:\n        result.append(num)\n        freq_map[num] -= 1\nprint(*result)",
      "JAVA": "import java.util.Scanner;\nimport java.util.HashMap;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line1 = sc.nextLine();\n        String line2 = sc.nextLine();\n\n        int[] nums1 = Arrays.stream(line1.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        int[] nums2 = Arrays.stream(line2.split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n        HashMap<Integer, Integer> freqMap = new HashMap<>();\n        for (int num : nums1) {\n            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);\n        }\n\n        ArrayList<Integer> resultList = new ArrayList<>();\n        for (int num : nums2) {\n            if (freqMap.containsKey(num) && freqMap.get(num) > 0) {\n                resultList.add(num);\n                freqMap.put(num, freqMap.get(num) - 1);\n            }\n        }\n\n        System.out.println(resultList.stream().map(Object::toString).collect(Collectors.joining(\" \")));\n    }\n}"
    },
    "editorial": "To find the intersection of two arrays where elements can appear multiple times, use a hash map to store the frequency of elements in one of the arrays (e.g., `nums1`). Then, iterate through the second array (`nums2`). For each element in `nums2`, check if it exists in the hash map and its count is greater than zero. If so, add it to the result array and decrement its count in the hash map. This ensures that each common element is included as many times as it appears in *both* arrays."
  },
  {
    "title": "Plus One",
    "description": "You are given a large integer represented as an integer array `digits`, where each `digits[i]` is the `i`th digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading zero, except for the number 0 itself. Increment the large integer by one and return the resulting array of digits.",
    "difficulty": "EASY",
    "tags": ["arrays", "maths"],
    "examples": {
      "PYTHON": {
        "input": "1 2 3",
        "output": "1 2 4",
        "explanation": "The array represents the integer 123. Incrementing by one gives 124."
      },
      "JAVASCRIPT": {
        "input": "4 3 2 1",
        "output": "4 3 2 2",
        "explanation": "The array represents the integer 4321. Incrementing by one gives 4322."
      },
      "JAVA": {
        "input": "9 9 9",
        "output": "1 0 0 0",
        "explanation": "The array represents the integer 999. Incrementing by one gives 1000."
      }
    },
    "constraints": "1 <= digits.length <= 100, 0 <= digits[i] <= 9. digits does not contain any leading zeros.",
    "hints": "Iterate from the least significant digit (rightmost). Handle carries. If a carry remains after the most significant digit, a new digit (1) needs to be prepended.",
    "testCases": [
      {
        "input": "0",
        "output": "1"
      },
      {
        "input": "8",
        "output": "9"
      },
      {
        "input": "9",
        "output": "1 0"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction plusOne(digits) {\n  const n = digits.length;\n\n  for (let i = n - 1; i >= 0; i--) {\n    if (digits[i] < 9) {\n      digits[i]++;\n      return digits;\n    } else {\n      digits[i] = 0;\n    }\n  }\n\n  // If we reached here, it means all digits were 9s (e.g., [9,9,9])\n  const newDigits = new Array(n + 1).fill(0);\n  newDigits[0] = 1;\n  return newDigits;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\nconst digits = input.split(' ').map(Number);\n\nconsole.log(plusOne(digits).join(' '));",
      "PYTHON": "def plus_one(digits: list[int]) -> list[int]:\n    n = len(digits)\n    \n    for i in range(n - 1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        else:\n            digits[i] = 0\n            \n    # If all digits were 9 (e.g., [9,9,9] -> [1,0,0,0])\n    return [1] + digits\n\nimport sys\ninput_line = sys.stdin.read().strip()\ndigits = list(map(int, input_line.split()))\n\nprint(*plus_one(digits))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static int[] plusOne(int[] digits) {\n        int n = digits.length;\n\n        for (int i = n - 1; i >= 0; i--) {\n            if (digits[i] < 9) {\n                digits[i]++;\n                return digits;\n            } else {\n                digits[i] = 0;\n            }\n        }\n\n        // If we reached here, it means all digits were 9s (e.g., [9,9,9])\n        int[] newDigits = new int[n + 1];\n        newDigits[0] = 1;\n        return newDigits;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        int[] digits = Arrays.stream(line.split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n        int[] result = plusOne(digits);\n        System.out.println(Arrays.stream(result).mapToObj(String::valueOf).collect(Collectors.joining(\" \")));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst digits = fs.readFileSync(0, 'utf-8').trim().split(' ').map(Number);\nconst n = digits.length;\n\nfor (let i = n - 1; i >= 0; i--) {\n  if (digits[i] < 9) {\n    digits[i]++;\n    console.log(digits.join(' '));\n    process.exit(0);\n  } else {\n    digits[i] = 0;\n  }\n}\n\nconst newDigits = new Array(n + 1).fill(0);\nnewDigits[0] = 1;\nconsole.log(newDigits.join(' '));",
      "PYTHON": "import sys\ndigits = list(map(int, sys.stdin.read().strip().split()))\nn = len(digits)\n\nfor i in range(n - 1, -1, -1):\n    if digits[i] < 9:\n        digits[i] += 1\n        print(*digits)\n        sys.exit(0)\n    else:\n        digits[i] = 0\n\nprint(*([1] + digits))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        int[] digits = Arrays.stream(line.split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n        int n = digits.length;\n\n        for (int i = n - 1; i >= 0; i--) {\n            if (digits[i] < 9) {\n                digits[i]++;\n                System.out.println(Arrays.stream(digits).mapToObj(String::valueOf).collect(Collectors.joining(\" \")));\n                return;\n            } else {\n                digits[i] = 0;\n            }\n        }\n\n        int[] newDigits = new int[n + 1];\n        newDigits[0] = 1;\n        System.out.println(Arrays.stream(newDigits).mapToObj(String::valueOf).collect(Collectors.joining(\" \")));\n    }\n}"
    },
    "editorial": "To increment a large integer represented as an array of digits, iterate the array from right to left (least significant digit to most significant). If the current digit is less than 9, increment it by one and return the array (no further carry). If the digit is 9, set it to 0 (a carry is generated). If the loop finishes and all digits were 9s (meaning a carry propagated to the most significant digit), a new array of size `n+1` is needed, with the first element as 1 and the rest as 0s."
  },
  
  {
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `i`th day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "difficulty": "EASY",
    "tags": ["arrays", "greedy"],
    "examples": {
      "PYTHON": {
        "input": "7 1 5 3 6 4",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
      },
      "JAVASCRIPT": {
        "input": "7 6 4 3 1",
        "output": "0",
        "explanation": "No transactions are profitable."
      },
      "JAVA": {
        "input": "2 4 1",
        "output": "2",
        "explanation": "Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2."
      }
    },
    "constraints": "1 <= prices.length <= 10^5, 0 <= prices[i] <= 10^4",
    "hints": "Maintain a variable to keep track of the minimum price seen so far and another for the maximum profit.",
    "testCases": [
      {
        "input": "1 2 3 4 5",
        "output": "4"
      },
      {
        "input": "5 4 3 2 1",
        "output": "0"
      },
      {
        "input": "3 2 6 5 0 3",
        "output": "3"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction maxProfit(prices) {\n  let minPrice = Infinity;\n  let maxProfit = 0;\n\n  for (let i = 0; i < prices.length; i++) {\n    if (prices[i] < minPrice) {\n      minPrice = prices[i];\n    } else if (prices[i] - minPrice > maxProfit) {\n      maxProfit = prices[i] - minPrice;\n    }\n  }\n  return maxProfit;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\nconst prices = input.split(' ').map(Number);\n\nconsole.log(maxProfit(prices));",
      "PYTHON": "def max_profit(prices: list[int]) -> int:\n    min_price = float('inf')\n    max_profit = 0\n\n    for price in prices:\n        if price < min_price:\n            min_price = price\n        elif price - min_price > max_profit:\n            max_profit = price - min_price\n    return max_profit\n\nimport sys\ninput_line = sys.stdin.read().strip()\nprices = list(map(int, input_line.split()))\n\nprint(max_profit(prices))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static int maxProfit(int[] prices) {\n        int minPrice = Integer.MAX_VALUE;\n        int maxProfit = 0;\n\n        for (int price : prices) {\n            if (price < minPrice) {\n                minPrice = price;\n            } else if (price - minPrice > maxProfit) {\n                maxProfit = price - minPrice;\n            }\n        }\n        return maxProfit;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        int[] prices = Arrays.stream(line.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        System.out.println(maxProfit(prices));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst prices = fs.readFileSync(0, 'utf-8').trim().split(' ').map(Number);\n\nlet minPrice = Infinity;\nlet maxProfit = 0;\n\nfor (let i = 0; i < prices.length; i++) {\n  if (prices[i] < minPrice) {\n    minPrice = prices[i];\n  } else if (prices[i] - minPrice > maxProfit) {\n    maxProfit = prices[i] - minPrice;\n  }\n}\nconsole.log(maxProfit);",
      "PYTHON": "import sys\nprices = list(map(int, sys.stdin.read().strip().split()))\n\nmin_price = float('inf')\nmax_profit = 0\n\nfor price in prices:\n    if price < min_price:\n        min_price = price\n    elif price - min_price > max_profit:\n        max_profit = price - min_price\nprint(max_profit)",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        int[] prices = Arrays.stream(line.split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n        int minPrice = Integer.MAX_VALUE;\n        int maxProfit = 0;\n\n        for (int price : prices) {\n            if (price < minPrice) {\n                minPrice = price;\n            } else if (price - minPrice > maxProfit) {\n                maxProfit = price - minPrice;\n            }\n        }\n        System.out.println(maxProfit);\n    }\n}"
    },
    "editorial": "To find the maximum profit, iterate through the `prices` array while keeping track of the minimum price encountered so far. At each day, calculate the potential profit if you were to sell on that day (current price - `minPrice`). Update `maxProfit` with the larger of the current `maxProfit` and this potential profit. The `minPrice` should always be updated to the lowest price seen up to the current day. If no profitable transaction is possible, `maxProfit` will remain 0."
  },
  {
    "title": "Single Number",
    "description": "Given a non-empty array of integers `nums`, every element appears twice except for one. Find that single one.",
    "difficulty": "EASY",
    "tags": ["arrays", "bit-manipulation", "hashmaps"],
    "examples": {
      "PYTHON": {
        "input": "2 2 1",
        "output": "1",
        "explanation": "1 is the unique element."
      },
      "JAVASCRIPT": {
        "input": "4 1 2 1 2",
        "output": "4",
        "explanation": "4 is the unique element."
      },
      "JAVA": {
        "input": "1",
        "output": "1",
        "explanation": "1 is the unique element."
      }
    },
    "constraints": "1 <= nums.length <= 3 * 10^4, -3 * 10^4 <= nums[i] <= 3 * 10^4. Each element in the array appears twice except for one element which appears only once.",
    "hints": "The XOR operation has the property `a ^ a = 0` and `a ^ 0 = a`. Consider XORing all elements.",
    "testCases": [
      {
        "input": "5 5 2 3 3",
        "output": "2"
      },
      {
        "input": "0 0 1",
        "output": "1"
      },
      {
        "input": "10",
        "output": "10"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction singleNumber(nums) {\n  let result = 0;\n  for (const num of nums) {\n    result ^= num;\n  }\n  return result;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\nconst nums = input.split(' ').map(Number);\n\nconsole.log(singleNumber(nums));",
      "PYTHON": "def single_number(nums: list[int]) -> int:\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\nimport sys\ninput_line = sys.stdin.read().strip()\nnums = list(map(int, input_line.split()))\n\nprint(single_number(nums))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static int singleNumber(int[] nums) {\n        int result = 0;\n        for (int num : nums) {\n            result ^= num;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        int[] nums = Arrays.stream(line.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        System.out.println(singleNumber(nums));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst nums = fs.readFileSync(0, 'utf-8').trim().split(' ').map(Number);\nlet result = 0;\nfor (const num of nums) {\n  result ^= num;\n}\nconsole.log(result);",
      "PYTHON": "import sys\nnums = list(map(int, sys.stdin.read().strip().split()))\nresult = 0\nfor num in nums:\n    result ^= num\nprint(result)",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        int[] nums = Arrays.stream(line.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        int result = 0;\n        for (int num : nums) {\n            result ^= num;\n        }\n        System.out.println(result);\n    }\n}"
    },
    "editorial": "The most efficient way to solve the 'Single Number' problem is to use the XOR bitwise operation. The XOR operation has the property that `a ^ a = 0` (XORing a number with itself results in 0) and `a ^ 0 = a` (XORing a number with 0 results in the number itself). If you XOR all elements in the array together, all numbers that appear twice will cancel each other out (result in 0), leaving only the single unique number."
  }
  {
    "title": "Median of Two Sorted Arrays",
    "description": "Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
    "difficulty": "HARD",
    "tags": [
      "arrays",
      "binary-search",
      "divide-and-conquer"
    ],
    "examples": {
      "PYTHON": {
        "input": "1 3\n2",
        "output": "2.0",
        "explanation": "Merged array = [1,2,3], median is 2."
      },
      "JAVASCRIPT": {
        "input": "1 2\n3 4",
        "output": "2.5",
        "explanation": "Merged array = [1,2,3,4], median is (2+3)/2 = 2.5."
      },
      "JAVA": {
        "input": "0 0\n0 0",
        "output": "0.0",
        "explanation": "Merged array = [0,0,0,0], median is (0+0)/2 = 0.0."
      }
    },
    "constraints": "nums1.length == m, nums2.length == n, 0 <= m <= 1000, 0 <= n <= 1000, 1 <= m + n <= 2000, -10^6 <= nums1[i], nums2[i] <= 10^6.",
    "hints": "This problem can be solved by finding the k-th smallest element in two sorted arrays. The median is either the (total_length/2 + 1)-th element or the average of (total_length/2)-th and (total_length/2 + 1)-th elements.",
    "testCases": [
      {
        "input": "5 10\n1 2 3",
        "output": "3.5"
      },
      {
        "input": "1 2 3 4 5\n6 7 8 9 10",
        "output": "5.5"
      },
      {
        "input": "100\n",
        "output": "100.0"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction findMedianSortedArrays(nums1, nums2) {\n  const m = nums1.length;\n  const n = nums2.length;\n  const totalLength = m + n;\n\n  if (totalLength % 2 === 1) {\n    return findKthElement(nums1, nums2, Math.floor(totalLength / 2) + 1);\n  } else {\n    const mid1 = findKthElement(nums1, nums2, totalLength / 2);\n    const mid2 = findKthElement(nums1, nums2, totalLength / 2 + 1);\n    return (mid1 + mid2) / 2.0;\n  }\n}\n\nfunction findKthElement(arr1, arr2, k) {\n  let i = 0;\n  let j = 0;\n\n  while (true) {\n    if (i === arr1.length) {\n      return arr2[j + k - 1];\n    }\n    if (j === arr2.length) {\n      return arr1[i + k - 1];\n    }\n    if (k === 1) {\n      return Math.min(arr1[i], arr2[j]);\n    }\n\n    let mid = Math.floor(k / 2);\n    let new_i = Math.min(i + mid, arr1.length) - 1;\n    let new_j = Math.min(j + mid, arr2.length) - 1;\n\n    if (arr1[new_i] <= arr2[new_j]) {\n      k -= (new_i - i + 1);\n      i = new_i + 1;\n    } else {\n      k -= (new_j - j + 1);\n      j = new_j + 1;\n    }\n  }\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst nums1 = input[0].split(' ').map(Number);\nconst nums2 = input[1] ? input[1].split(' ').map(Number) : [];\n\nconsole.log(findMedianSortedArrays(nums1, nums2));",
      "PYTHON": "def find_median_sorted_arrays(nums1: list[int], nums2: list[int]) -> float:\n    m, n = len(nums1), len(nums2)\n    total_length = m + n\n\n    if total_length % 2 == 1:\n        return float(find_kth_element(nums1, nums2, total_length // 2 + 1))\n    else:\n        mid1 = find_kth_element(nums1, nums2, total_length // 2)\n        mid2 = find_kth_element(nums1, nums2, total_length // 2 + 1)\n        return (mid1 + mid2) / 2.0\n\ndef find_kth_element(arr1, arr2, k):\n    len1, len2 = len(arr1), len(arr2)\n    i, j = 0, 0\n\n    while True:\n        if i == len1:\n            return arr2[j + k - 1]\n        if j == len2:\n            return arr1[i + k - 1]\n        if k == 1:\n            return min(arr1[i], arr2[j])\n\n        mid = k // 2\n        new_i = min(i + mid, len1) - 1\n        new_j = min(j + mid, len2) - 1\n\n        if arr1[new_i] <= arr2[new_j]:\n            k -= (new_i - i + 1)\n            i = new_i + 1\n        else:\n            k -= (new_j - j + 1)\n            j = new_j + 1\n\nimport sys\ninput_lines = sys.stdin.read().strip().split('\\n')\nnums1 = list(map(int, input_lines[0].split()))\nnums2 = list(map(int, input_lines[1].split())) if len(input_lines) > 1 and input_lines[1] else []\n\nprint(find_median_sorted_arrays(nums1, nums2))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int m = nums1.length;\n        int n = nums2.length;\n        int totalLength = m + n;\n\n        if (totalLength % 2 == 1) {\n            return findKthElement(nums1, nums2, totalLength / 2 + 1);\n        } else {\n            double mid1 = findKthElement(nums1, nums2, totalLength / 2);\n            double mid2 = findKthElement(nums1, nums2, totalLength / 2 + 1);\n            return (mid1 + mid2) / 2.0;\n        }\n    }\n\n    private static int findKthElement(int[] arr1, int[] arr2, int k) {\n        int i = 0;\n        int j = 0;\n        int len1 = arr1.length;\n        int len2 = arr2.length;\n\n        while (true) {\n            if (i == len1) {\n                return arr2[j + k - 1];\n            }\n            if (j == len2) {\n                return arr1[i + k - 1];\n            }\n            if (k == 1) {\n                return Math.min(arr1[i], arr2[j]);\n            }\n\n            int mid = k / 2;\n            int new_i = Math.min(i + mid, len1) - 1;\n            int new_j = Math.min(j + mid, len2) - 1;\n\n            if (arr1[new_i] <= arr2[new_j]) {\n                k -= (new_i - i + 1);\n                i = new_i + 1;\n            } else {\n                k -= (new_j - j + 1);\n                j = new_j + 1;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line1 = sc.nextLine();\n        String line2 = sc.nextLine();\n\n        int[] nums1 = Arrays.stream(line1.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        int[] nums2 = line2.isEmpty() ? new int[0] : Arrays.stream(line2.split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n        System.out.println(findMedianSortedArrays(nums1, nums2));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst nums1 = input[0].split(' ').map(Number);\nconst nums2 = input[1] ? input[1].split(' ').map(Number) : [];\n\nconst m = nums1.length;\nconst n = nums2.length;\nconst totalLength = m + n;\n\nfunction findKthElement(arr1, arr2, k) {\n  let i = 0;\n  let j = 0;\n\n  while (true) {\n    if (i === arr1.length) {\n      return arr2[j + k - 1];\n    }\n    if (j === arr2.length) {\n      return arr1[i + k - 1];\n    }\n    if (k === 1) {\n      return Math.min(arr1[i], arr2[j]);\n    }\n\n    let mid = Math.floor(k / 2);\n    let new_i = Math.min(i + mid, arr1.length) - 1;\n    let new_j = Math.min(j + mid, arr2.length) - 1;\n\n    if (arr1[new_i] <= arr2[new_j]) {\n      k -= (new_i - i + 1);\n      i = new_i + 1;\n    } else {\n      k -= (new_j - j + 1);\n      j = new_j + 1;\n    }\n  }\n}\n\nif (totalLength % 2 === 1) {\n  console.log(findKthElement(nums1, nums2, Math.floor(totalLength / 2) + 1));\n} else {\n  const mid1 = findKthElement(nums1, nums2, totalLength / 2);\n  const mid2 = findKthElement(nums1, nums2, totalLength / 2 + 1);\n  console.log((mid1 + mid2) / 2.0);\n}",
      "PYTHON": "import sys\n\ninput_lines = sys.stdin.read().strip().split('\\n')\nnums1 = list(map(int, input_lines[0].split()))\nnums2 = list(map(int, input_lines[1].split())) if len(input_lines) > 1 and input_lines[1] else []\n\ndef find_kth_element(arr1, arr2, k):\n    len1, len2 = len(arr1), len(arr2)\n    i, j = 0, 0\n\n    while True:\n        if i == len1:\n            return arr2[j + k - 1]\n        if j == len2:\n            return arr1[i + k - 1]\n        if k == 1:\n            return min(arr1[i], arr2[j])\n\n        mid = k // 2\n        new_i = min(i + mid, len1) - 1\n        new_j = min(j + mid, len2) - 1\n\n        if arr1[new_i] <= arr2[new_j]:\n            k -= (new_i - i + 1)\n            i = new_i + 1\n        else:\n            k -= (new_j - j + 1)\n            j = new_j + 1\n\nm, n = len(nums1), len(nums2)\ntotal_length = m + n\n\nif total_length % 2 == 1:\n    print(float(find_kth_element(nums1, nums2, total_length // 2 + 1)))\nelse:\n    mid1 = find_kth_element(nums1, nums2, total_length // 2)\n    mid2 = find_kth_element(nums1, nums2, total_length // 2 + 1)\n    print((mid1 + mid2) / 2.0)",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    private static int findKthElement(int[] arr1, int[] arr2, int k) {\n        int i = 0;\n        int j = 0;\n        int len1 = arr1.length;\n        int len2 = arr2.length;\n\n        while (true) {\n            if (i == len1) {\n                return arr2[j + k - 1];\n            }\n            if (j == len2) {\n                return arr1[i + k - 1];\n            }\n            if (k == 1) {\n                return Math.min(arr1[i], arr2[j]);\n            }\n\n            int mid = k / 2;\n            int new_i = Math.min(i + mid, len1) - 1;\n            int new_j = Math.min(j + mid, len2) - 1;\n\n            if (arr1[new_i] <= arr2[new_j]) {\n                k -= (new_i - i + 1);\n                i = new_i + 1;\n            } else {\n                k -= (new_j - j + 1);\n                j = new_j + 1;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line1 = sc.nextLine();\n        String line2 = sc.nextLine();\n\n        int[] nums1 = Arrays.stream(line1.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        int[] nums2 = line2.isEmpty() ? new int[0] : Arrays.stream(line2.split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n        int m = nums1.length;\n        int n = nums2.length;\n        int totalLength = m + n;\n\n        if (totalLength % 2 == 1) {\n            System.out.println((double) findKthElement(nums1, nums2, totalLength / 2 + 1));\n        } else {\n            double mid1 = findKthElement(nums1, nums2, totalLength / 2);\n            double mid2 = findKthElement(nums1, nums2, totalLength / 2 + 1);\n            System.out.println((mid1 + mid2) / 2.0);\n        }\n    }\n}"
    },
    "editorial": "The problem asks for the median of two sorted arrays with O(log (m+n)) complexity. This strongly suggests a binary search approach. The core idea is to find the k-th smallest element in the combined sorted array. The median is either the (total_length/2 + 1)-th element (if total length is odd) or the average of the (total_length/2)-th and (total_length/2 + 1)-th elements (if total length is even). The `findKthElement` function works by recursively eliminating half of the elements in each step, similar to binary search. In each step, we compare the middle elements of the first `k/2` elements of the remaining parts of `arr1` and `arr2` to decide which half to discard. This ensures logarithmic time complexity."
  },
  {
    "title": "Merge k Sorted Lists",
    "description": "You are given an array of `k` linked-lists `lists`, each sorted in ascending order. Merge all the linked-lists into one sorted linked list and return it.",
    "difficulty": "HARD",
    "tags": [
      "linked-list",
      "heap",
      "divide-and-conquer"
    ],
    "examples": {
      "PYTHON": {
        "input": "1->4->5\n1->3->4\n2->6",
        "output": "1->1->2->3->4->4->5->6",
        "explanation": "Merging three sorted lists into one."
      },
      "JAVASCRIPT": {
        "input": "\n\n1",
        "output": "1",
        "explanation": "Merging an empty list, an empty list, and a list with one node."
      },
      "JAVA": {
        "input": "",
        "output": "null",
        "explanation": "Merging an empty array of lists results in an empty list."
      }
    },
    "constraints": "k == lists.length, 0 <= k <= 10^4. 0 <= lists[i].length <= 500. -10^4 <= Node.val <= 10^4. The sum of lists[i].length will not exceed 10^4.",
    "hints": "A min-heap (priority queue) can efficiently find the smallest element among the heads of all lists. Alternatively, a divide-and-conquer approach can be used by merging pairs of lists recursively.",
    "testCases": [
      {
        "input": "1->2->3\n4->5->6",
        "output": "1->2->3->4->5->6"
      },
      {
        "input": "7\n1\n3",
        "output": "1->3->7"
      },
      {
        "input": "10->20\n5->15",
        "output": "5->10->15->20"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nclass ListNode {\n  constructor(val, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\n// Helper to parse linked list from string\nfunction parseLinkedList(s) {\n  if (s === 'null' || s === '') return null;\n  const values = s.split('->').map(Number);\n  let head = new ListNode(values[0]);\n  let current = head;\n  for (let i = 1; i < values.length; i++) {\n    current.next = new ListNode(values[i]);\n    current = current.next;\n  }\n  return head;\n}\n\n// Helper to convert linked list to string for output\nfunction serializeLinkedList(head) {\n  if (!head) return 'null';\n  let result = [];\n  let current = head;\n  while (current) {\n    result.push(current.val);\n    current = current.next;\n  }\n  return result.join('->');\n}\n\nclass MinPriorityQueue {\n  constructor() {\n    this.heap = [];\n  }\n\n  push(node) {\n    this.heap.push(node);\n    this._bubbleUp(this.heap.length - 1);\n  }\n\n  pop() {\n    if (this.isEmpty()) return null;\n    const min = this.heap[0];\n    const last = this.heap.pop();\n    if (this.heap.length > 0) {\n      this.heap[0] = last;\n      this._sinkDown(0);\n    }\n    return min;\n  }\n\n  peek() {\n    return this.heap[0];\n  }\n\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n\n  _bubbleUp(index) {\n    while (index > 0) {\n      let parentIndex = Math.floor((index - 1) / 2);\n      if (this.heap[index].val < this.heap[parentIndex].val) {\n        [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n        index = parentIndex;\n      } else {\n        break;\n      }\n    }\n  }\n\n  _sinkDown(index) {\n    const lastIndex = this.heap.length - 1;\n    while (true) {\n      let leftChildIndex = 2 * index + 1;\n      let rightChildIndex = 2 * index + 2;\n      let smallestChildIndex = index;\n\n      if (leftChildIndex <= lastIndex && this.heap[leftChildIndex].val < this.heap[smallestChildIndex].val) {\n        smallestChildIndex = leftChildIndex;\n      }\n      if (rightChildIndex <= lastIndex && this.heap[rightChildIndex].val < this.heap[smallestChildIndex].val) {\n        smallestChildIndex = rightChildIndex;\n      }\n\n      if (smallestChildIndex !== index) {\n        [this.heap[index], this.heap[smallestChildIndex]] = [this.heap[smallestChildIndex], this.heap[index]];\n        index = smallestChildIndex;\n      } else {\n        break;\n      }\n    }\n  }\n}\n\nfunction mergeKLists(lists) {\n  const pq = new MinPriorityQueue();\n\n  for (const list of lists) {\n    if (list) {\n      pq.push(list);\n    }\n  }\n\n  let dummyHead = new ListNode(0);\n  let current = dummyHead;\n\n  while (!pq.isEmpty()) {\n    const smallest = pq.pop();\n    current.next = smallest;\n    current = current.next;\n    if (smallest.next) {\n      pq.push(smallest.next);\n    }\n  }\n\n  return dummyHead.next;\n}\n\nconst inputLines = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst lists = inputLines.map(parseLinkedList);\n\nconst mergedListHead = mergeKLists(lists);\nconsole.log(serializeLinkedList(mergedListHead));",
      "PYTHON": "import heapq\nimport sys\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n    # Required for heapq to compare ListNode objects\n    def __lt__(self, other):\n        return self.val < other.val\n\n# Helper to parse linked list from string\ndef parse_linked_list(s):\n    if not s or s == 'null':\n        return None\n    values = list(map(int, s.split('->')))\n    head = ListNode(values[0])\n    current = head\n    for i in range(1, len(values)):\n        current.next = ListNode(values[i])\n        current = current.next\n    return head\n\n# Helper to convert linked list to string for output\ndef serialize_linked_list(head):\n    if not head: return 'null'\n    result = []\n    current = head\n    while current:\n        result.append(str(current.val))\n        current = current.next\n    return '->'.join(result)\n\ndef merge_k_lists(lists: list[ListNode]) -> ListNode:\n    min_heap = []\n\n    for i, head in enumerate(lists):\n        if head:\n            # Store (value, list_index, node) to handle tie-breaking for values\n            # Python's heapq needs comparable elements. If ListNode objects are not compared,\n            # a tuple (node.val, i, node) can be used. i as a tie-breaker.\n            heapq.heappush(min_heap, (head.val, i, head))\n\n    dummy_head = ListNode(0)\n    current = dummy_head\n\n    while min_heap:\n        val, _, node = heapq.heappop(min_heap)\n        current.next = node\n        current = current.next\n        if node.next:\n            heapq.heappush(min_heap, (node.next.val, _, node.next))\n    \n    return dummy_head.next\n\ninput_lines = sys.stdin.read().strip().split('\\n')\nlists = [parse_linked_list(line) for line in input_lines if line]\n\nmerged_list_head = merge_k_lists(lists)\nprint(serialize_linked_list(merged_list_head))",
      "JAVA": "import java.util.Scanner;\nimport java.util.PriorityQueue;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\npublic class Main {\n\n    // Helper to parse linked list from string\n    public static ListNode parseLinkedList(String s) {\n        if (s == null || s.isEmpty() || s.equals(\"null\")) return null;\n        String[] values = s.split(\"->\");\n        if (values.length == 0) return null;\n        ListNode head = new ListNode(Integer.parseInt(values[0]));\n        ListNode current = head;\n        for (int i = 1; i < values.length; i++) {\n            current.next = new ListNode(Integer.parseInt(values[i]));\n            current = current.next;\n        }\n        return head;\n    }\n\n    // Helper to convert linked list to string for output\n    public static String serializeLinkedList(ListNode head) {\n        if (head == null) return \"null\";\n        StringBuilder sb = new StringBuilder();\n        ListNode current = head;\n        while (current != null) {\n            sb.append(current.val);\n            if (current.next != null) {\n                sb.append(\"->\");\n            }\n            current = current.next;\n        }\n        return sb.toString();\n    }\n\n    public static ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) {\n            return null;\n        }\n\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(Comparator.comparingInt(node -> node.val));\n\n        for (ListNode list : lists) {\n            if (list != null) {\n                pq.add(list);\n            }\n        }\n\n        ListNode dummyHead = new ListNode(0);\n        ListNode current = dummyHead;\n\n        while (!pq.isEmpty()) {\n            ListNode smallest = pq.poll();\n            current.next = smallest;\n            current = current.next;\n            if (smallest.next != null) {\n                pq.add(smallest.next);\n            }\n        }\n\n        return dummyHead.next;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        ArrayList<ListNode> listNodes = new ArrayList<>();\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            listNodes.add(parseLinkedList(line));\n        }\n        ListNode[] listsArray = listNodes.toArray(new ListNode[0]);\n\n        ListNode mergedListHead = mergeKLists(listsArray);\n        System.out.println(serializeLinkedList(mergedListHead));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nclass ListNode {\n  constructor(val, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction parseLinkedList(s) {\n  if (s === 'null' || s === '') return null;\n  const values = s.split('->').map(Number);\n  let head = new ListNode(values[0]);\n  let current = head;\n  for (let i = 1; i < values.length; i++) {\n    current.next = new ListNode(values[i]);\n    current = current.next;\n  }\n  return head;\n}\n\nfunction serializeLinkedList(head) {\n  if (!head) return 'null';\n  let result = [];\n  let current = head;\n  while (current) {\n    result.push(current.val);\n    current = current.next;\n  }\n  return result.join('->');\n}\n\nclass MinPriorityQueue {\n  constructor() {\n    this.heap = [];\n  }\n\n  push(node) {\n    this.heap.push(node);\n    this._bubbleUp(this.heap.length - 1);\n  }\n\n  pop() {\n    if (this.isEmpty()) return null;\n    const min = this.heap[0];\n    const last = this.heap.pop();\n    if (this.heap.length > 0) {\n      this.heap[0] = last;\n      this._sinkDown(0);\n    }\n    return min;\n  }\n\n  peek() {\n    return this.heap[0];\n  }\n\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n\n  _bubbleUp(index) {\n    while (index > 0) {\n      let parentIndex = Math.floor((index - 1) / 2);\n      if (this.heap[index].val < this.heap[parentIndex].val) {\n        [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n        index = parentIndex;\n      } else {\n        break;\n      }\n    }\n  }\n\n  _sinkDown(index) {\n    const lastIndex = this.heap.length - 1;\n    while (true) {\n      let leftChildIndex = 2 * index + 1;\n      let rightChildIndex = 2 * index + 2;\n      let smallestChildIndex = index;\n\n      if (leftChildIndex <= lastIndex && this.heap[leftChildIndex].val < this.heap[smallestChildIndex].val) {\n        smallestChildIndex = leftChildIndex;\n      }\n      if (rightChildIndex <= lastIndex && this.heap[rightChildIndex].val < this.heap[smallestChildIndex].val) {\n        smallestChildIndex = rightChildIndex;\n      }\n\n      if (smallestChildIndex !== index) {\n        [this.heap[index], this.heap[smallestChildIndex]] = [this.heap[smallestChildIndex], this.heap[index]];\n        index = smallestChildIndex;\n      } else {\n        break;\n      }\n    }\n  }\n}\n\nconst inputLines = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst lists = inputLines.map(parseLinkedList);\n\nconst pq = new MinPriorityQueue();\n\nfor (const list of lists) {\n  if (list) {\n    pq.push(list);\n  }\n}\n\nlet dummyHead = new ListNode(0);\nlet current = dummyHead;\n\nwhile (!pq.isEmpty()) {\n  const smallest = pq.pop();\n  current.next = smallest;\n  current = current.next;\n  if (smallest.next) {\n    pq.push(smallest.next);\n  }\n}\n\nconsole.log(serializeLinkedList(dummyHead.next));",
      "PYTHON": "import heapq\nimport sys\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef parse_linked_list(s):\n    if not s or s == 'null':\n        return None\n    values = list(map(int, s.split('->')))\n    head = ListNode(values[0])\n    current = head\n    for i in range(1, len(values)):\n        current.next = ListNode(values[i])\n        current = current.next\n    return head\n\ndef serialize_linked_list(head):\n    if not head: return 'null'\n    result = []\n    current = head\n    while current:\n        result.append(str(current.val))\n        current = current.next\n    return '->'.join(result)\n\ninput_lines = sys.stdin.read().strip().split('\\n')\nlists = [parse_linked_list(line) for line in input_lines if line]\n\nmin_heap = []\n\nfor i, head in enumerate(lists):\n    if head:\n        heapq.heappush(min_heap, (head.val, i, head))\n\ndummy_head = ListNode(0)\ncurrent = dummy_head\n\nwhile min_heap:\n    val, _, node = heapq.heappop(min_heap)\n    current.next = node\n    current = current.next\n    if node.next:\n        heapq.heappush(min_heap, (node.next.val, _, node.next))\n\nprint(serialize_linked_list(dummy_head.next))",
      "JAVA": "import java.util.Scanner;\nimport java.util.PriorityQueue;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\npublic class Main {\n    public static ListNode parseLinkedList(String s) {\n        if (s == null || s.isEmpty() || s.equals(\"null\")) return null;\n        String[] values = s.split(\"->\");\n        if (values.length == 0) return null;\n        ListNode head = new ListNode(Integer.parseInt(values[0]));\n        ListNode current = head;\n        for (int i = 1; i < values.length; i++) {\n            current.next = new ListNode(Integer.parseInt(values[i]));\n            current = current.next;\n        }\n        return head;\n    }\n\n    public static String serializeLinkedList(ListNode head) {\n        if (head == null) return \"null\";\n        StringBuilder sb = new StringBuilder();\n        ListNode current = head;\n        while (current != null) {\n            sb.append(current.val);\n            if (current.next != null) {\n                sb.append(\"->\");\n            }\n            current = current.next;\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        ArrayList<ListNode> listNodes = new ArrayList<>();\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            listNodes.add(parseLinkedList(line));\n        }\n        ListNode[] listsArray = listNodes.toArray(new ListNode[0]);\n\n        if (listsArray == null || listsArray.length == 0) {\n            System.out.println(\"null\");\n            return;\n        }\n\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(Comparator.comparingInt(node -> node.val));\n\n        for (ListNode list : listsArray) {\n            if (list != null) {\n                pq.add(list);\n            }\n        }\n\n        ListNode dummyHead = new ListNode(0);\n        ListNode current = dummyHead;\n\n        while (!pq.isEmpty()) {\n            ListNode smallest = pq.poll();\n            current.next = smallest;\n            current = current.next;\n            if (smallest.next != null) {\n                pq.add(smallest.next);\n            }\n        }\n\n        System.out.println(serializeLinkedList(dummyHead.next));\n    }\n}"
    },
    "editorial": "This problem can be efficiently solved using a min-priority queue (min-heap). Initialize a min-heap and add the head of each non-empty linked list to it. Then, repeatedly extract the smallest element from the heap. This extracted element is the next node in our merged sorted list. After extracting a node, if it has a `next` node, add that `next` node to the heap. Continue this process until the heap becomes empty. The time complexity will be O(N log k), where N is the total number of nodes across all lists and k is the number of lists, because each of the N nodes is added and extracted from the heap once, and heap operations take O(log k) time."
  },
  {
    "title": "Trapping Rain Water",
    "description": "Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
    "difficulty": "HARD",
    "tags": [
      "arrays",
      "two-pointers",
      "dynamic-programming",
      "stack"
    ],
    "examples": {
      "PYTHON": {
        "input": "0 1 0 2 1 0 1 3 2 1 2 1",
        "output": "6",
        "explanation": "The elevation map [0,1,0,2,1,0,1,3,2,1,2,1] traps 6 units of rain water."
      },
      "JAVASCRIPT": {
        "input": "4 2 0 3 2 5",
        "output": "9",
        "explanation": "The elevation map [4,2,0,3,2,5] traps 9 units of rain water."
      },
      "JAVA": {
        "input": "0",
        "output": "0",
        "explanation": "An empty or single-bar map traps no water."
      }
    },
    "constraints": "n == height.length, 1 <= n <= 2 * 10^4, 0 <= height[i] <= 10^5.",
    "hints": "For each bar, the amount of water it can trap is determined by the minimum of the maximum height to its left and the maximum height to its right, minus its own height. This can be optimized using two pointers.",
    "testCases": [
      {
        "input": "1 0 1",
        "output": "1"
      },
      {
        "input": "2 0 2",
        "output": "2"
      },
      {
        "input": "5 5 1 7 1 1 5",
        "output": "14"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction trap(height) {\n  let left = 0;\n  let right = height.length - 1;\n  let leftMax = 0;\n  let rightMax = 0;\n  let trappedWater = 0;\n\n  while (left < right) {\n    if (height[left] < height[right]) {\n      if (height[left] >= leftMax) {\n        leftMax = height[left];\n      } else {\n        trappedWater += leftMax - height[left];\n      }\n      left++;\n    } else {\n      if (height[right] >= rightMax) {\n        rightMax = height[right];\n      } else {\n        trappedWater += rightMax - height[right];\n      }\n      right--;\n    }\n  }\n  return trappedWater;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\nconst height = input.split(' ').map(Number);\n\nconsole.log(trap(height));",
      "PYTHON": "def trap(height: list[int]) -> int:\n    if not height: return 0\n\n    left = 0\n    right = len(height) - 1\n    left_max = 0\n    right_max = 0\n    trapped_water = 0\n\n    while left < right:\n        if height[left] < height[right]:\n            if height[left] >= left_max:\n                left_max = height[left]\n            else:\n                trapped_water += left_max - height[left]\n            left += 1\n        else:\n            if height[right] >= right_max:\n                right_max = height[right]\n            else:\n                trapped_water += right_max - height[right]\n            right -= 1\n\n    return trapped_water\n\nimport sys\ninput_line = sys.stdin.read().strip()\nheight = list(map(int, input_line.split()))\n\nprint(trap(height))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static int trap(int[] height) {\n        if (height == null || height.length < 3) {\n            return 0;\n        }\n\n        int left = 0;\n        int right = height.length - 1;\n        int leftMax = 0;\n        int rightMax = 0;\n        int trappedWater = 0;\n\n        while (left < right) {\n            if (height[left] < height[right]) {\n                if (height[left] >= leftMax) {\n                    leftMax = height[left];\n                } else {\n                    trappedWater += leftMax - height[left];\n                }\n                left++;\n            } else {\n                if (height[right] >= rightMax) {\n                    rightMax = height[right];\n                } else {\n                    trappedWater += rightMax - height[right];\n                }\n                right--;\n            }\n        }\n        return trappedWater;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        int[] height = Arrays.stream(line.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        System.out.println(trap(height));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst height = fs.readFileSync(0, 'utf-8').trim().split(' ').map(Number);\n\nif (height.length < 3) {\n  console.log(0);\n} else {\n  let left = 0;\n  let right = height.length - 1;\n  let leftMax = 0;\n  let rightMax = 0;\n  let trappedWater = 0;\n\n  while (left < right) {\n    if (height[left] < height[right]) {\n      if (height[left] >= leftMax) {\n        leftMax = height[left];\n      } else {\n        trappedWater += leftMax - height[left];\n      }\n      left++;\n    } else {\n      if (height[right] >= rightMax) {\n        rightMax = height[right];\n      } else {\n        trappedWater += rightMax - height[right];\n      }\n      right--;\n    }\n  }\n  console.log(trappedWater);\n}",
      "PYTHON": "import sys\nheight = list(map(int, sys.stdin.read().strip().split()))\n\nif not height or len(height) < 3:\n    print(0)\nelse:\n    left = 0\n    right = len(height) - 1\n    left_max = 0\n    right_max = 0\n    trapped_water = 0\n\n    while left < right:\n        if height[left] < height[right]:\n            if height[left] >= left_max:\n                left_max = height[left]\n            else:\n                trapped_water += left_max - height[left]\n            left += 1\n        else:\n            if height[right] >= right_max:\n                right_max = height[right]\n            else:\n                trapped_water += right_max - height[right]\n            right -= 1\n\n    print(trapped_water)",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        int[] height = Arrays.stream(line.split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n        if (height == null || height.length < 3) {\n            System.out.println(0);\n            return;\n        }\n\n        int left = 0;\n        int right = height.length - 1;\n        int leftMax = 0;\n        int rightMax = 0;\n        int trappedWater = 0;\n\n        while (left < right) {\n            if (height[left] < height[right]) {\n                if (height[left] >= leftMax) {\n                    leftMax = height[left];\n                } else {\n                    trappedWater += leftMax - height[left];\n                }\n                left++;\n            } else {\n                if (height[right] >= rightMax) {\n                    rightMax = height[right];\n                } else {\n                    trappedWater += rightMax - height[right];\n                }\n                right--;\n            }\n        }\n        System.out.println(trappedWater);\n    }\n}"
    },
    "editorial": "The 'Trapping Rain Water' problem can be solved efficiently using a two-pointer approach. Initialize `left` at the beginning and `right` at the end of the `height` array. Also, maintain `leftMax` and `rightMax` to store the maximum height encountered from the left and right, respectively. In each step, move the pointer that points to the shorter bar. If `height[left] < height[right]`, then any water trapped at `left` is limited by `height[left]` (since `rightMax` will be at least `height[right]` and thus `height[left]` is the limiting factor). If `height[left]` is less than `leftMax`, add `leftMax - height[left]` to `trappedWater`; otherwise, update `leftMax`. Similarly, if `height[right] <= height[left]`, apply the logic to the right side. This approach ensures that we correctly calculate the trapped water in O(N) time and O(1) space."
  },
  {
    "title": "Longest Valid Parentheses",
    "description": "Given a string `s` containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.",
    "difficulty": "HARD",
    "tags": [
      "strings",
      "stack",
      "dynamic-programming"
    ],
    "examples": {
      "PYTHON": {
        "input": "(()",
        "output": "2",
        "explanation": "The longest valid parentheses substring is \"()\"."
      },
      "JAVASCRIPT": {
        "input": ")()())",
        "output": "4",
        "explanation": "The longest valid parentheses substring is \"()()\"."
      },
      "JAVA": {
        "input": "",
        "output": "0",
        "explanation": "An empty string has no valid parentheses."
      }
    },
    "constraints": "0 <= s.length <= 3 * 10^4. s[i] is '(' or ')'.",
    "hints": "A stack can be used to keep track of the indices of opening parentheses. When a closing parenthesis is encountered, pop from the stack. The length of the valid substring can be calculated. Or, use dynamic programming where `dp[i]` stores the length of the longest valid parentheses substring ending at index `i`.",
    "testCases": [
      {
        "input": "()(()))))",
        "output": "6"
      },
      {
        "input": "((()))",
        "output": "6"
      },
      {
        "input": "()()",
        "output": "4"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction longestValidParentheses(s) {\n  let maxLength = 0;\n  const stack = [-1]; // Initialize stack with -1 to handle first valid pair\n\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === '(') {\n      stack.push(i);\n    } else {\n      stack.pop();\n      if (stack.length === 0) {\n        stack.push(i); // Push current index as new base for invalid close\n      } else {\n        maxLength = Math.max(maxLength, i - stack[stack.length - 1]);\n      }\n    }\n  }\n  return maxLength;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\n\nconsole.log(longestValidParentheses(input));",
      "PYTHON": "def longest_valid_parentheses(s: str) -> int:\n    max_length = 0\n    stack = [-1] # Initialize stack with -1 to handle first valid pair\n\n    for i, char in enumerate(s):\n        if char == '(':\n            stack.append(i)\n        else:\n            stack.pop()\n            if not stack:\n                stack.append(i) # Push current index as new base for invalid close\n            else:\n                max_length = max(max_length, i - stack[-1])\n    return max_length\n\nimport sys\ninput_line = sys.stdin.read().strip()\n\nprint(longest_valid_parentheses(input_line))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Stack;\nimport java.util.Arrays;\n\npublic class Main {\n    public static int longestValidParentheses(String s) {\n        int maxLength = 0;\n        Stack<Integer> stack = new Stack<>();\n        stack.push(-1); // Initialize stack with -1 to handle first valid pair\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == '(') {\n                stack.push(i);\n            } else { // c == ')'\n                stack.pop();\n                if (stack.isEmpty()) {\n                    stack.push(i); // Push current index as new base for invalid close\n                } else {\n                    maxLength = Math.max(maxLength, i - stack.peek());\n                }\n            }\n        }\n        return maxLength;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.nextLine();\n        System.out.println(longestValidParentheses(s));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst s = fs.readFileSync(0, 'utf-8').trim();\n\nlet maxLength = 0;\nconst stack = [-1];\n\nfor (let i = 0; i < s.length; i++) {\n  if (s[i] === '(') {\n    stack.push(i);\n  } else {\n    stack.pop();\n    if (stack.length === 0) {\n      stack.push(i);\n    } else {\n      maxLength = Math.max(maxLength, i - stack[stack.length - 1]);\n    }\n  }\n}\nconsole.log(maxLength);",
      "PYTHON": "import sys\ns = sys.stdin.read().strip()\n\nmax_length = 0\nstack = [-1]\n\nfor i, char in enumerate(s):\n    if char == '(':\n        stack.append(i)\n    else:\n        stack.pop()\n        if not stack:\n            stack.append(i)\n        else:\n            max_length = max(max_length, i - stack[-1])\n\nprint(max_length)",
      "JAVA": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.nextLine();\n\n        int maxLength = 0;\n        Stack<Integer> stack = new Stack<>();\n        stack.push(-1);\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == '(') {\n                stack.push(i);\n            } else {\n                stack.pop();\n                if (stack.isEmpty()) {\n                    stack.push(i);\n                } else {\n                    maxLength = Math.max(maxLength, i - stack.peek());\n                }\n            }\n        }\n        System.out.println(maxLength);\n    }\n}"
    },
    "editorial": "This 'Longest Valid Parentheses' problem can be solved using a stack. Initialize a stack and push -1 onto it as a base. Iterate through the string: if an opening parenthesis '(' is encountered, push its index onto the stack. If a closing parenthesis ')' is encountered, pop from the stack. If the stack becomes empty, it means the current ')' doesn't have a matching '(', so push the current index onto the stack to mark a new potential starting point for a valid substring. If the stack is not empty, it means we found a valid pair; calculate the length as `current_index - stack.peek()` and update `maxLength`. This approach correctly tracks the longest valid substring in O(N) time."
  },
  {
    "title": "Reverse Nodes in k-Group",
    "description": "Given the `head` of a linked list, reverse the nodes of the list `k` at a time, and return the modified list. `k` is a positive integer and is less than or equal to the number of nodes in the linked list. If the number of nodes is not a multiple of `k`, then left-out nodes in the end should remain as it is.",
    "difficulty": "HARD",
    "tags": [
      "linked-list",
      "recursion"
    ],
    "examples": {
      "PYTHON": {
        "input": "1->2->3->4->5\n2",
        "output": "2->1->4->3->5",
        "explanation": "Nodes reversed in groups of 2."
      },
      "JAVASCRIPT": {
        "input": "1->2->3->4->5\n3",
        "output": "3->2->1->4->5",
        "explanation": "Nodes reversed in groups of 3. The last two remain as is."
      },
      "JAVA": {
        "input": "1\n1",
        "output": "1",
        "explanation": "Single node, k=1, no change."
      }
    },
    "constraints": "The number of nodes in the list is in the range [0, 5000]. 1 <= k <= 5000. 0 <= Node.val <= 1000.",
    "hints": "Break the problem into subproblems: reverse a group of k nodes, then recursively call the function for the next group. A helper function to reverse a fixed number of nodes can be useful.",
    "testCases": [
      {
        "input": "1->2->3->4->5->6\n3",
        "output": "3->2->1->6->5->4"
      },
      {
        "input": "1->2->3->4\n5",
        "output": "1->2->3->4"
      },
      {
        "input": "null\n2",
        "output": "null"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nclass ListNode {\n  constructor(val, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction parseLinkedList(s) {\n  if (s === 'null' || s === '') return null;\n  const values = s.split('->').map(Number);\n  let head = new ListNode(values[0]);\n  let current = head;\n  for (let i = 1; i < values.length; i++) {\n    current.next = new ListNode(values[i]);\n    current = current.next;\n  }\n  return head;\n}\n\nfunction serializeLinkedList(head) {\n  if (!head) return 'null';\n  let result = [];\n  let current = head;\n  while (current) {\n    result.push(current.val);\n    current = current.next;\n  }\n  return result.join('->');\n}\n\nfunction reverseKGroup(head, k) {\n  let current = head;\n  let count = 0;\n  while (current !== null && count < k) {\n    current = current.next;\n    count++;\n  }\n\n  if (count === k) {\n    // Reverse the first k nodes\n    current = head;\n    let prev = null;\n    for (let i = 0; i < k; i++) {\n      let nextNode = current.next;\n      current.next = prev;\n      prev = current;\n      current = nextNode;\n    }\n    // head is now the last node of the reversed group\n    // prev is the new head of the reversed group\n    head.next = reverseKGroup(current, k);\n    return prev;\n  } else {\n    return head; // Not enough nodes to reverse, return as is\n  }\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst head = parseLinkedList(input[0]);\nconst k = parseInt(input[1]);\n\nconst resultHead = reverseKGroup(head, k);\nconsole.log(serializeLinkedList(resultHead));",
      "PYTHON": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef parse_linked_list(s):\n    if not s or s == 'null':\n        return None\n    values = list(map(int, s.split('->')))\n    head = ListNode(values[0])\n    current = head\n    for i in range(1, len(values)):\n        current.next = ListNode(values[i])\n        current = current.next\n    return head\n\ndef serialize_linked_list(head):\n    if not head: return 'null'\n    result = []\n    current = head\n    while current:\n        result.append(str(current.val))\n        current = current.next\n    return '->'.join(result)\n\ndef reverse_k_group(head: ListNode, k: int) -> ListNode:\n    current = head\n    count = 0\n    while current and count < k:\n        current = current.next\n        count += 1\n\n    if count == k:\n        # Reverse the first k nodes\n        current = head\n        prev = None\n        for _ in range(k):\n            next_node = current.next\n            current.next = prev\n            prev = current\n            current = next_node\n        \n        # head is now the last node of the reversed group\n        # prev is the new head of the reversed group\n        head.next = reverse_k_group(current, k)\n        return prev\n    else:\n        return head # Not enough nodes to reverse, return as is\n\nimport sys\ninput_lines = sys.stdin.read().strip().split('\\n')\nhead_str = input_lines[0]\nk_val = int(input_lines[1])\n\nhead = parse_linked_list(head_str)\nresult_head = reverse_k_group(head, k_val)\nprint(serialize_linked_list(result_head))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\npublic class Main {\n    public static ListNode parseLinkedList(String s) {\n        if (s == null || s.isEmpty() || s.equals(\"null\")) return null;\n        String[] values = s.split(\"->\");\n        if (values.length == 0) return null;\n        ListNode head = new ListNode(Integer.parseInt(values[0]));\n        ListNode current = head;\n        for (int i = 1; i < values.length; i++) {\n            current.next = new ListNode(Integer.parseInt(values[i]));\n            current = current.next;\n        }\n        return head;\n    }\n\n    public static String serializeLinkedList(ListNode head) {\n        if (head == null) return \"null\";\n        StringBuilder sb = new StringBuilder();\n        ListNode current = head;\n        while (current != null) {\n            sb.append(current.val);\n            if (current.next != null) {\n                sb.append(\"->\");\n            }\n            current = current.next;\n        }\n        return sb.toString();\n    }\n\n    public static ListNode reverseKGroup(ListNode head, int k) {\n        ListNode current = head;\n        int count = 0;\n        while (current != null && count < k) {\n            current = current.next;\n            count++;\n        }\n\n        if (count == k) {\n            // Reverse the first k nodes\n            current = head; // current now points to the head of the k-group\n            ListNode prev = null;\n            for (int i = 0; i < k; i++) {\n                ListNode nextNode = current.next;\n                current.next = prev;\n                prev = current;\n                current = nextNode;\n            }\n            // head (original head of the group) is now the last node of the reversed group\n            // prev is the new head of the reversed group\n            head.next = reverseKGroup(current, k); // Recurse for the rest of the list\n            return prev;\n        } else {\n            return head; // Not enough nodes to reverse, return as is\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line1 = sc.nextLine();\n        int k = sc.nextInt();\n\n        ListNode head = parseLinkedList(line1);\n        ListNode resultHead = reverseKGroup(head, k);\n        System.out.println(serializeLinkedList(resultHead));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nclass ListNode {\n  constructor(val, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction parseLinkedList(s) {\n  if (s === 'null' || s === '') return null;\n  const values = s.split('->').map(Number);\n  let head = new ListNode(values[0]);\n  let current = head;\n  for (let i = 1; i < values.length; i++) {\n    current.next = new ListNode(values[i]);\n    current = current.next;\n  }\n  return head;\n}\n\nfunction serializeLinkedList(head) {\n  if (!head) return 'null';\n  let result = [];\n  let current = head;\n  while (current) {\n    result.push(current.val);\n    current = current.next;\n  }\n  return result.join('->');\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst head = parseLinkedList(input[0]);\nconst k = parseInt(input[1]);\n\nfunction reverse(head, k) {\n  let current = head;\n  let count = 0;\n  while (current !== null && count < k) {\n    current = current.next;\n    count++;\n  }\n\n  if (count === k) {\n    current = head;\n    let prev = null;\n    for (let i = 0; i < k; i++) {\n      let nextNode = current.next;\n      current.next = prev;\n      prev = current;\n      current = nextNode;\n    }\n    head.next = reverse(current, k);\n    return prev;\n  } else {\n    return head;\n  }\n}\n\nconst resultHead = reverse(head, k);\nconsole.log(serializeLinkedList(resultHead));",
      "PYTHON": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef parse_linked_list(s):\n    if not s or s == 'null':\n        return None\n    values = list(map(int, s.split('->')))\n    head = ListNode(values[0])\n    current = head\n    for i in range(1, len(values)):\n        current.next = ListNode(values[i])\n        current = current.next\n    return head\n\ndef serialize_linked_list(head):\n    if not head: return 'null'\n    result = []\n    current = head\n    while current:\n        result.append(str(current.val))\n        current = current.next\n    return '->'.join(result)\n\nimport sys\ninput_lines = sys.stdin.read().strip().split('\\n')\nhead_str = input_lines[0]\nk_val = int(input_lines[1])\n\nhead = parse_linked_list(head_str)\n\ndef reverse_k_group_impl(head, k):\n    current = head\n    count = 0\n    while current and count < k:\n        current = current.next\n        count += 1\n\n    if count == k:\n        current = head\n        prev = None\n        for _ in range(k):\n            next_node = current.next\n            current.next = prev\n            prev = current\n            current = next_node\n        \n        head.next = reverse_k_group_impl(current, k)\n        return prev\n    else:\n        return head\n\nresult_head = reverse_k_group_impl(head, k_val)\nprint(serialize_linked_list(result_head))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\npublic class Main {\n    public static ListNode parseLinkedList(String s) {\n        if (s == null || s.isEmpty() || s.equals(\"null\")) return null;\n        String[] values = s.split(\"->\");\n        if (values.length == 0) return null;\n        ListNode head = new ListNode(Integer.parseInt(values[0]));\n        ListNode current = head;\n        for (int i = 1; i < values.length; i++) {\n            current.next = new ListNode(Integer.parseInt(values[i]));\n            current = current.next;\n        }\n        return head;\n    }\n\n    public static String serializeLinkedList(ListNode head) {\n        if (head == null) return \"null\";\n        StringBuilder sb = new StringBuilder();\n        ListNode current = head;\n        while (current != null) {\n            sb.append(current.val);\n            if (current.next != null) {\n                sb.append(\"->\");\n            }\n            current = current.next;\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line1 = sc.nextLine();\n        int k = sc.nextInt();\n\n        ListNode head = parseLinkedList(line1);\n\n        // Recursive helper function for reversing k-group\n        ListNode resultHead = reverse(head, k);\n        System.out.println(serializeLinkedList(resultHead));\n    }\n\n    private static ListNode reverse(ListNode head, int k) {\n        ListNode current = head;\n        int count = 0;\n        while (current != null && count < k) {\n            current = current.next;\n            count++;\n        }\n\n        if (count == k) {\n            current = head;\n            ListNode prev = null;\n            for (int i = 0; i < k; i++) {\n                ListNode nextNode = current.next;\n                current.next = prev;\n                prev = current;\n                current = nextNode;\n            }\n            head.next = reverse(current, k);\n            return prev;\n        } else {\n            return head;\n        }\n    }\n}"
    },
    "editorial": "The 'Reverse Nodes in k-Group' problem is best solved using a recursive approach. First, check if there are at least `k` nodes remaining in the list. If not, return the current head as is (no reversal needed for the remaining tail). If there are `k` or more nodes, reverse the first `k` nodes using standard linked list reversal (three pointers: `prev`, `current`, `nextTemp`). After reversing the first `k` nodes, the original `head` of this group will now be its tail, and its `next` pointer should point to the result of recursively calling `reverseKGroup` on the `(k+1)`-th node (which is `current` after the loop). The `prev` pointer (which is the original `k`-th node) becomes the new head of this reversed group and should be returned."
  },
  {
    "title": "Sliding Window Maximum",
    "description": "You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.",
    "difficulty": "HARD",
    "tags": [
      "arrays",
      "sliding-window",
      "deque",
      "heap"
    ],
    "examples": {
      "PYTHON": {
        "input": "1 3 -1 -3 5 3 6 7\n3",
        "output": "3 3 5 5 6 7",
        "explanation": "Window 1: [1,3,-1], max is 3\nWindow 2: [3,-1,-3], max is 3\nWindow 3: [-1,-3,5], max is 5\nWindow 4: [-3,5,3], max is 5\nWindow 5: [5,3,6], max is 6\nWindow 6: [3,6,7], max is 7"
      },
      "JAVASCRIPT": {
        "input": "1\n1",
        "output": "1",
        "explanation": "Single element, window size 1."
      },
      "JAVA": {
        "input": "9 11\n2",
        "output": "11",
        "explanation": "Window 1: [9,11], max is 11."
      }
    },
    "constraints": "1 <= nums.length <= 10^5, -10^4 <= nums[i] <= 10^4, 1 <= k <= nums.length.",
    "hints": "A double-ended queue (deque) can be used to store indices of elements in decreasing order of their values. This allows for O(1) retrieval of the maximum and efficient window updates.",
    "testCases": [
      {
        "input": "1 3 1 2 0 5\n3",
        "output": "3 3 2 5"
      },
      {
        "input": "10 9 8 7 6 5\n3",
        "output": "10 9 8 7"
      },
      {
        "input": "5 4 3 2 1\n1",
        "output": "5 4 3 2 1"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction maxSlidingWindow(nums, k) {\n  const result = [];\n  const deque = []; // Stores indices\n\n  for (let i = 0; i < nums.length; i++) {\n    // Remove indices from front of deque that are out of current window\n    if (deque.length > 0 && deque[0] <= i - k) {\n      deque.shift();\n    }\n\n    // Remove indices from back of deque whose elements are smaller than current element\n    while (deque.length > 0 && nums[deque[deque.length - 1]] <= nums[i]) {\n      deque.pop();\n    }\n\n    // Add current element's index to deque\n    deque.push(i);\n\n    // If window has reached size k, add max (element at deque[0]) to result\n    if (i >= k - 1) {\n      result.push(nums[deque[0]]);\n    }\n  }\n\n  return result;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst nums = input[0].split(' ').map(Number);\nconst k = parseInt(input[1]);\n\nconsole.log(maxSlidingWindow(nums, k).join(' '));",
      "PYTHON": "from collections import deque\nimport sys\n\ndef max_sliding_window(nums: list[int], k: int) -> list[int]:\n    result = []\n    dq = deque() # Stores indices\n\n    for i in range(len(nums)):\n        # Remove indices from front of deque that are out of current window\n        if dq and dq[0] <= i - k:\n            dq.popleft()\n        \n        # Remove indices from back of deque whose elements are smaller than current element\n        while dq and nums[dq[-1]] <= nums[i]:\n            dq.pop()\n        \n        # Add current element's index to deque\n        dq.append(i)\n\n        # If window has reached size k, add max (element at dq[0]) to result\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    \n    return result\n\ninput_lines = sys.stdin.read().strip().split('\\n')\nnums = list(map(int, input_lines[0].split()))\nk = int(input_lines[1])\n\nprint(*max_sliding_window(nums, k))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.LinkedList;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static int[] maxSlidingWindow(int[] nums, int k) {\n        if (nums == null || nums.length == 0 || k <= 0) {\n            return new int[0];\n        }\n\n        List<Integer> result = new ArrayList<>();\n        Deque<Integer> deque = new LinkedList<>(); // Stores indices\n\n        for (int i = 0; i < nums.length; i++) {\n            // Remove indices from front of deque that are out of current window\n            if (!deque.isEmpty() && deque.peekFirst() <= i - k) {\n                deque.removeFirst();\n            }\n\n            // Remove indices from back of deque whose elements are smaller than current element\n            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {\n                deque.removeLast();\n            }\n\n            // Add current element's index to deque\n            deque.addLast(i);\n\n            // If window has reached size k, add max (element at deque.peekFirst()) to result\n            if (i >= k - 1) {\n                result.add(nums[deque.peekFirst()]);\n            }\n        }\n\n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line1 = sc.nextLine();\n        int[] nums = Arrays.stream(line1.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        int k = sc.nextInt();\n\n        int[] result = maxSlidingWindow(nums, k);\n        System.out.println(Arrays.stream(result).mapToObj(String::valueOf).collect(Collectors.joining(\" \")));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst nums = input[0].split(' ').map(Number);\nconst k = parseInt(input[1]);\n\nconst result = [];\nconst deque = [];\n\nfor (let i = 0; i < nums.length; i++) {\n  if (deque.length > 0 && deque[0] <= i - k) {\n    deque.shift();\n  }\n\n  while (deque.length > 0 && nums[deque[deque.length - 1]] <= nums[i]) {\n    deque.pop();\n  }\n\n  deque.push(i);\n\n  if (i >= k - 1) {\n    result.push(nums[deque[0]]);\n  }\n}\n\nconsole.log(result.join(' '));",
      "PYTHON": "from collections import deque\nimport sys\n\ninput_lines = sys.stdin.read().strip().split('\\n')\nnums = list(map(int, input_lines[0].split()))\nk = int(input_lines[1])\n\nresult = []\ndq = deque()\n\nfor i in range(len(nums)):\n    if dq and dq[0] <= i - k:\n        dq.popleft()\n    \n    while dq and nums[dq[-1]] <= nums[i]:\n        dq.pop()\n    \n    dq.append(i)\n\n    if i >= k - 1:\n        result.append(nums[dq[0]])\n\nprint(*result)",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.LinkedList;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line1 = sc.nextLine();\n        int[] nums = Arrays.stream(line1.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        int k = sc.nextInt();\n\n        if (nums == null || nums.length == 0 || k <= 0) {\n            System.out.println(\"\");\n            return;\n        }\n\n        List<Integer> result = new ArrayList<>();\n        Deque<Integer> deque = new LinkedList<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            if (!deque.isEmpty() && deque.peekFirst() <= i - k) {\n                deque.removeFirst();\n            }\n\n            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {\n                deque.removeLast();\n            }\n\n            deque.addLast(i);\n\n            if (i >= k - 1) {\n                result.add(nums[deque.peekFirst()]);\n            }\n        }\n\n        System.out.println(result.stream().map(Object::toString).collect(Collectors.joining(\" \")));\n    }\n}"
    },
    "editorial": "The 'Sliding Window Maximum' problem can be optimally solved using a deque (double-ended queue). The deque will store indices of elements in the current window in a decreasing order of their values. When iterating through the array: 1. Remove indices from the front of the deque that are no longer within the current window. 2. Remove indices from the back of the deque whose corresponding values are less than or equal to the current element's value (as they can no longer be the maximum). 3. Add the current element's index to the back of the deque. 4. Once the window has reached size `k` (i.e., `i >= k-1`), the maximum element in the current window is always at `nums[deque[0]]`. Add this to the result. This approach ensures O(N) time complexity as each element is pushed and popped from the deque at most once."
  },
  {
    "title": "Largest Rectangle in Histogram",
    "description": "Given an array of integers `heights` representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
    "difficulty": "HARD",
    "tags": [
      "arrays",
      "stack",
      "dynamic-programming"
    ],
    "examples": {
      "PYTHON": {
        "input": "2 1 5 6 2 3",
        "output": "10",
        "explanation": "The largest rectangle has area 10 (bars of height 5 and 6)."
      },
      "JAVASCRIPT": {
        "input": "2 4",
        "output": "4",
        "explanation": "The largest rectangle has area 4 (bar of height 4)."
      },
      "JAVA": {
        "input": "1 1 1 1",
        "output": "4",
        "explanation": "The largest rectangle has area 4."
      }
    },
    "constraints": "1 <= heights.length <= 10^5, 0 <= heights[i] <= 10^4.",
    "hints": "A monotonic stack can be used to efficiently find the nearest smaller element to the left and right for each bar. This information is crucial for calculating the maximum width for each bar as a potential height.",
    "testCases": [
      {
        "input": "0",
        "output": "0"
      },
      {
        "input": "7 2 8 9 1 3",
        "output": "16"
      },
      {
        "input": "6 2 5 4 5 1 6",
        "output": "12"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction largestRectangleArea(heights) {\n  let maxArea = 0;\n  const stack = []; // Stores indices\n\n  // Add a 0 height bar at the end to process all remaining bars in stack\n  heights.push(0);\n\n  for (let i = 0; i < heights.length; i++) {\n    while (stack.length > 0 && heights[i] < heights[stack[stack.length - 1]]) {\n      const h = heights[stack.pop()];\n      const w = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n      maxArea = Math.max(maxArea, h * w);\n    }\n    stack.push(i);\n  }\n  return maxArea;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim();\nconst heights = input.split(' ').map(Number);\n\nconsole.log(largestRectangleArea(heights));",
      "PYTHON": "def largest_rectangle_area(heights: list[int]) -> int:\n    max_area = 0\n    stack = [] # Stores indices\n\n    # Add a 0 height bar at the end to process all remaining bars in stack\n    heights.append(0)\n\n    for i, h in enumerate(heights):\n        while stack and h < heights[stack[-1]]:\n            height_val = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height_val * width)\n        stack.append(i)\n\n    return max_area\n\nimport sys\ninput_line = sys.stdin.read().strip()\nheights = list(map(int, input_line.split()))\n\nprint(largest_rectangle_area(heights))",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.Stack;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static int largestRectangleArea(int[] heights) {\n        if (heights == null || heights.length == 0) {\n            return 0;\n        }\n\n        int maxArea = 0;\n        Stack<Integer> stack = new Stack<>(); // Stores indices\n\n        // Create a new array with 0 at the end to handle remaining bars in stack\n        int[] newHeights = Arrays.copyOf(heights, heights.length + 1);\n        newHeights[heights.length] = 0;\n\n        for (int i = 0; i < newHeights.length; i++) {\n            while (!stack.isEmpty() && newHeights[i] < newHeights[stack.peek()]) {\n                int h = newHeights[stack.pop()];\n                int w = stack.isEmpty() ? i : i - stack.peek() - 1;\n                maxArea = Math.max(maxArea, h * w);\n            }\n            stack.push(i);\n        }\n        return maxArea;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        int[] heights = Arrays.stream(line.split(\" \")).mapToInt(Integer::parseInt).toArray();\n        System.out.println(largestRectangleArea(heights));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst heights = fs.readFileSync(0, 'utf-8').trim().split(' ').map(Number);\n\nif (heights.length === 0) {\n  console.log(0);\n  process.exit(0);\n}\n\nlet maxArea = 0;\nconst stack = [];\n\nconst extendedHeights = [...heights, 0]; // Add a 0 at the end\n\nfor (let i = 0; i < extendedHeights.length; i++) {\n  while (stack.length > 0 && extendedHeights[i] < extendedHeights[stack[stack.length - 1]]) {\n    const h = extendedHeights[stack.pop()];\n    const w = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n    maxArea = Math.max(maxArea, h * w);\n  }\n  stack.push(i);\n}\n\nconsole.log(maxArea);",
      "PYTHON": "import sys\n\nheights = list(map(int, sys.stdin.read().strip().split()))\n\nif not heights:\n    print(0)\n    sys.exit(0)\n\nmax_area = 0\nstack = [] # Stores indices\n\nextended_heights = heights + [0] # Add a 0 height bar at the end\n\nfor i, h in enumerate(extended_heights):\n    while stack and h < extended_heights[stack[-1]]:\n        height_val = extended_heights[stack.pop()]\n        width = i if not stack else i - stack[-1] - 1\n        max_area = max(max_area, height_val * width)\n    stack.append(i)\n\nprint(max_area)",
      "JAVA": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.Stack;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        int[] heights = Arrays.stream(line.split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n        if (heights == null || heights.length == 0) {\n            System.out.println(0);\n            return;\n        }\n\n        int maxArea = 0;\n        Stack<Integer> stack = new Stack<>();\n\n        int[] newHeights = Arrays.copyOf(heights, heights.length + 1);\n        newHeights[heights.length] = 0; // Sentinel value\n\n        for (int i = 0; i < newHeights.length; i++) {\n            while (!stack.isEmpty() && newHeights[i] < newHeights[stack.peek()]) {\n                int h = newHeights[stack.pop()];\n                int w = stack.isEmpty() ? i : i - stack.peek() - 1;\n                maxArea = Math.max(maxArea, h * w);\n            }\n            stack.push(i);\n        }\n        System.out.println(maxArea);\n    }\n}"
    },
    "editorial": "The 'Largest Rectangle in Histogram' problem can be solved using a monotonic stack. The stack will store indices of bars in increasing order of their heights. When iterating through the `heights` array (with a sentinel 0 at the end): 1. If the current bar's height is less than the height of the bar at the top of the stack, it means the bar at the top of the stack has found its right boundary. Pop it, calculate the area using its height and the width (current index minus the new top of stack's index minus 1, or `i` if stack is empty). Update `maxArea`. Repeat until the stack is empty or the current bar's height is not less than the stack's top. 2. Push the current bar's index onto the stack. This ensures each bar is considered as the minimum height for a potential rectangle, and its largest possible width is calculated based on its nearest smaller elements to its left and right."
  },
  {
    "title": "Word Ladder",
    "description": "A transformation sequence from `word_list[0]` to `word_list[N-1]` using a dictionary `word_list` is a sequence of words `beginWord`, `word1`, `word2`, ..., `endWord` such that: 1. Every adjacent pair of words differs by a single letter. 2. Every `word_i` in the sequence is in `word_list`. Given two words, `beginWord` and `endWord`, and a dictionary `word_list`, return the length of the shortest transformation sequence from `beginWord` to `endWord`, or 0 if no such sequence exists.",
    "difficulty": "HARD",
    "tags": [
      "bfs",
      "graph",
      "strings"
    ],
    "examples": {
      "PYTHON": {
        "input": "hit\ncog\nhot dot dog lot log cog",
        "output": "5",
        "explanation": "One shortest sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", length 5."
      },
      "JAVASCRIPT": {
        "input": "hit\nxyz\nhot dot dog lot log cog",
        "output": "0",
        "explanation": "No transformation sequence exists to 'xyz'."
      },
      "JAVA": {
        "input": "a\nc\na b c",
        "output": "2",
        "explanation": "Sequence \"a\" -> \"c\", length 2."
      }
    },
    "constraints": "1 <= beginWord.length <= 10, endWord.length == beginWord.length, 1 <= wordList.length <= 5000, wordList[i].length == beginWord.length. beginWord, endWord, and wordList[i] consist of lowercase English letters. beginWord != endWord. All the words in wordList are unique.",
    "hints": "This is a shortest path problem on a graph. The words are nodes, and an edge exists between two words if they differ by one letter. Breadth-First Search (BFS) is ideal for finding the shortest path in an unweighted graph.",
    "testCases": [
      {
        "input": "teach\nreach\nteach preach reach",
        "output": "2"
      },
      {
        "input": "a\nb\na b",
        "output": "2"
      },
      {
        "input": "red\nfox\nred bed bad fix fox",
        "output": "4"
      }
    ],
    "codeSnippets": {
      "JAVASCRIPT": "const fs = require('fs');\n\nfunction ladderLength(beginWord, endWord, wordList) {\n  const wordSet = new Set(wordList);\n  if (!wordSet.has(endWord)) {\n    return 0;\n  }\n\n  const queue = [[beginWord, 1]];\n  const visited = new Set([beginWord]);\n\n  while (queue.length > 0) {\n    const [currentWord, level] = queue.shift();\n\n    if (currentWord === endWord) {\n      return level;\n    }\n\n    for (let i = 0; i < currentWord.length; i++) {\n      const charArray = currentWord.split('');\n      for (let charCode = 97; charCode <= 122; charCode++) { // 'a' to 'z'\n        const char = String.fromCharCode(charCode);\n        charArray[i] = char;\n        const nextWord = charArray.join('');\n\n        if (wordSet.has(nextWord) && !visited.has(nextWord)) {\n          visited.add(nextWord);\n          queue.push([nextWord, level + 1]);\n        }\n      }\n    }\n  }\n\n  return 0;\n}\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst beginWord = input[0];\nconst endWord = input[1];\nconst wordList = input[2].split(' ');\n\nconsole.log(ladderLength(beginWord, endWord, wordList));",
      "PYTHON": "from collections import deque\nimport sys\n\ndef ladder_length(begin_word: str, end_word: str, word_list: list[str]) -> int:\n    word_set = set(word_list)\n    if end_word not in word_set:\n        return 0\n\n    queue = deque([(begin_word, 1)]) # (word, level)\n    visited = {begin_word}\n\n    while queue:\n        current_word, level = queue.popleft()\n\n        if current_word == end_word:\n            return level\n        \n        for i in range(len(current_word)):\n            for char_code in range(ord('a'), ord('z') + 1):\n                char = chr(char_code)\n                next_word_list = list(current_word)\n                next_word_list[i] = char\n                next_word = ''.join(next_word_list)\n\n                if next_word in word_set and next_word not in visited:\n                    visited.add(next_word)\n                    queue.append((next_word, level + 1))\n    \n    return 0\n\ninput_lines = sys.stdin.read().strip().split('\\n')\nbegin_word = input_lines[0]\nend_word = input_lines[1]\nword_list = input_lines[2].split()\n\nprint(ladder_length(begin_word, end_word, word_list))",
      "JAVA": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.Arrays;\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Main {\n    public static int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> wordSet = new HashSet<>(wordList);\n        if (!wordSet.contains(endWord)) {\n            return 0;\n        }\n\n        Queue<String[]> queue = new LinkedList<>(); // Stores [word, level]\n        queue.offer(new String[]{beginWord, \"1\"});\n        Set<String> visited = new HashSet<>();\n        visited.add(beginWord);\n\n        while (!queue.isEmpty()) {\n            String[] currentEntry = queue.poll();\n            String currentWord = currentEntry[0];\n            int level = Integer.parseInt(currentEntry[1]);\n\n            if (currentWord.equals(endWord)) {\n                return level;\n            }\n\n            char[] charArray = currentWord.toCharArray();\n            for (int i = 0; i < charArray.length; i++) {\n                char originalChar = charArray[i];\n                for (char c = 'a'; c <= 'z'; c++) {\n                    charArray[i] = c;\n                    String nextWord = new String(charArray);\n\n                    if (wordSet.contains(nextWord) && !visited.contains(nextWord)) {\n                        visited.add(nextWord);\n                        queue.offer(new String[]{nextWord, String.valueOf(level + 1)});\n                    }\n                }\n                charArray[i] = originalChar; // Backtrack\n            }\n        }\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String beginWord = sc.nextLine();\n        String endWord = sc.nextLine();\n        List<String> wordList = Arrays.asList(sc.nextLine().split(\" \"));\n        System.out.println(ladderLength(beginWord, endWord, wordList));\n    }\n}"
    },
    "referenceSolutions": {
      "JAVASCRIPT": "const fs = require('fs');\n\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst beginWord = input[0];\nconst endWord = input[1];\nconst wordList = input[2].split(' ');\n\nconst wordSet = new Set(wordList);\nif (!wordSet.has(endWord)) {\n  console.log(0);\n  process.exit(0);\n}\n\nconst queue = [[beginWord, 1]];\nconst visited = new Set([beginWord]);\n\nlet found = false;\nlet result = 0;\n\nwhile (queue.length > 0) {\n  const [currentWord, level] = queue.shift();\n\n  if (currentWord === endWord) {\n    found = true;\n    result = level;\n    break;\n  }\n\n  for (let i = 0; i < currentWord.length; i++) {\n    const charArray = currentWord.split('');\n    for (let charCode = 97; charCode <= 122; charCode++) {\n      const char = String.fromCharCode(charCode);\n      charArray[i] = char;\n      const nextWord = charArray.join('');\n\n      if (wordSet.has(nextWord) && !visited.has(nextWord)) {\n        visited.add(nextWord);\n        queue.push([nextWord, level + 1]);\n      }\n    }\n  }\n}\n\nconsole.log(result);",
      "PYTHON": "from collections import deque\nimport sys\n\ninput_lines = sys.stdin.read().strip().split('\\n')\nbegin_word = input_lines[0]\nend_word = input_lines[1]\nword_list = input_lines[2].split()\n\nword_set = set(word_list)\nif end_word not in word_set:\n    print(0)\n    sys.exit(0)\n\nqueue = deque([(begin_word, 1)])\nvisited = {begin_word}\n\nfound = False\nresult = 0\n\nwhile queue:\n    current_word, level = queue.popleft()\n\n    if current_word == end_word:\n        found = True\n        result = level\n        break\n    \n    for i in range(len(current_word)):\n        for char_code in range(ord('a'), ord('z') + 1):\n            char = chr(char_code)\n            next_word_list = list(current_word)\n            next_word_list[i] = char\n            next_word = ''.join(next_word_list)\n\n            if next_word in word_set and next_word not in visited:\n                visited.add(next_word)\n                queue.append((next_word, level + 1))\n\nprint(result)",
      "JAVA": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.Arrays;\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String beginWord = sc.nextLine();\n        String endWord = sc.nextLine();\n        List<String> wordList = Arrays.asList(sc.nextLine().split(\" \"));\n\n        Set<String> wordSet = new HashSet<>(wordList);\n        if (!wordSet.contains(endWord)) {\n            System.out.println(0);\n            return;\n        }\n\n        Queue<String[]> queue = new LinkedList<>();\n        queue.offer(new String[]{beginWord, \"1\"});\n        Set<String> visited = new HashSet<>();\n        visited.add(beginWord);\n\n        int result = 0;\n        while (!queue.isEmpty()) {\n            String[] currentEntry = queue.poll();\n            String currentWord = currentEntry[0];\n            int level = Integer.parseInt(currentEntry[1]);\n\n            if (currentWord.equals(endWord)) {\n                result = level;\n                break;\n            }\n\n            char[] charArray = currentWord.toCharArray();\n            for (int i = 0; i < charArray.length; i++) {\n                char originalChar = charArray[i];\n                for (char c = 'a'; c <= 'z'; c++) {\n                    charArray[i] = c;\n                    String nextWord = new String(charArray);\n\n                    if (wordSet.contains(nextWord) && !visited.contains(nextWord)) {\n                        visited.add(nextWord);\n                        queue.offer(new String[]{nextWord, String.valueOf(level + 1)});\n                    }\n                }\n                charArray[i] = originalChar;\n            }\n        }\n        System.out.println(result);\n    }\n}"
    },
    "editorial": "This problem can be modeled as a shortest path problem on an unweighted graph, making Breadth-First Search (BFS) the ideal algorithm. Create a graph where each word in `wordList` (and `beginWord`) is a node, and an edge exists between two words if they differ by exactly one letter. Perform a BFS starting from `beginWord`. In each step, generate all possible one-letter transformations of the current word. If a transformed word exists in `wordList` and has not been visited, add it to the queue with an incremented level (distance). The first time `endWord` is reached, its corresponding level will be the shortest transformation sequence length. If the queue becomes empty and `endWord` was never reached, return 0."
  }
]
